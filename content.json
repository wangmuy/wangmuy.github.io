{"pages":[{"title":"About","date":"2019-05-02T14:43:32.204Z","path":"about/index.html","text":""},{"title":"Tags","date":"2019-05-02T14:43:32.224Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2019-05-02T14:43:32.211Z","path":"categories/index.html","text":""}],"posts":[{"title":"keras examples 总结","date":"2017-09-07T07:55:18.000Z","path":"misc/keras-examples/","text":"NLPimdb 评论分类目标: 划分 imdb 评论电影好坏 imdb_bidirectional_lstm.py 方案 123Densebidirectional lstmEmbedding 超参数 1234567sentence len = 100vocab size = 20000embedding size = 128lstm unroll = 64lstm dropout = 0.5optimizer = adamloss = binary_crossentropy 指标 ~0.8146 after 4 epochs imdb_cnn.py 方案 1234DenseGlobalMaxPooling1DConv1DEmbedding 超参数 123456789sentence len = 400vocab size = 5000embedding size = 50# filters = 250kernel size = 3activation = relufilter strides = 1optimizer = adamloss = binary_crossentropy 指标 ~0.89 after 2 epochs imdb_cnn_lstm.py 方案 1234DenseLSTMConv1DEmbedding 超参数 12345678910sentence len = 100vocab size = 20000embedding size = 128# filters = 64kernel size = 5activation = relufilter strides = 1lstm unroll = 70optimizer = adamloss = binary_crossentropy 指标 ~0.8498 after 2epochs imdb_fasttext.py 方案 fasttext 123DenseGlobalAveragePooling1DEmbedding 超参数 1234sentence len = 400vocab size = 20000embedding size = 50if ngram_range &gt; 1: add_ngram() 添加匹配的 ngram 到 x_train/x_test 指标 ~0.8813 after 5epochs for Uni-gram ~0.9056 after 5 epochs for Bi-gram imdb_lstm.py 方案 123DenseLSTMEmbedding 超参数 12345sentence len = 80vocab size = 20000embedding size = 128optimizer = adamloss = binary_crossentropy 指标 test set: ~0.8084 lstm_benchmark.py 方案 123DenseLSTM(不同实现)Embedding 超参数 123456789sentence len = 80vocab size = 20000embedding size = 256optimizer = adamloss = binary_crossentropyfor modes in [0, 1, 2]: lstm unroll = 256 lstm dropout = 0.2 lstm implementation = mode 指标 123model=0: val_acc ~= 0.8108model=1: val_acc ~= 0.8163model=2: val_acc ~= 0.7946 reuters 新闻分类reuters_mlp.py 方案 12Dense(10, activation=&apos;softmax&apos;)Dense(512, activation=&apos;relu&apos;, dropout=0.5) 超参数 123setence len = 1000optimizer = adamloss = categorical_crossentropy 指标 test set: ~0.7911 reuters_mlp_relu_vs_selu.py 方案 123Dense(num_classes, activation=&apos;softmax&apos;)n_dense 个 Dense(dense_units, kernel_initializer, activation, dropoutImpl, droput_rate)Dense(dense_units, kernel_initializer) 超参数 123456789101112131415161718192021num_classes = 分类个数network1: n_dense = 6 dense_units = 16 activation = relu droputImpl = Dropout droptout_rate = 0.5 kernel_initializer = glorot_uniform optimizer = sgd loss = categorical_crossentropynetwork2: n_dense = 6 dense_units = 16 activation = selu droputImpl = AlphaDropout droptout_rate = 0.1 kernel_initializer = lecun_normal optimizer = sgd loss = categorical_crossentropy 指标 network1: test set ~0.5124 network2: test set ~0.6745 20 Newsgroup目标: Newsgroup 文章分类 pretrained_word_embeddings.py 方案 1234567891011导入 glove embedding(不可训练)Dense(128)FlattenMaxPooling1D(35)Conv1D(128, 5, activation=&apos;relu&apos;)MaxPooling1D(5)Conv1D(128, 5, activation=&apos;relu&apos;)MaxPooling1D(5)Conv1D(128, 5, activation=&apos;relu&apos;)Embedding 超参数 12345sentence len = 1000vocab size = min(20000, dataset实际token数)embedding size = 100optimizer = rmsproploss = categorical_crossentropy 指标 val_acc = ~0.7417 Visual RecognitionMNIST 数字识别TBD","tags":[],"categories":[{"name":"mldl","slug":"mldl","permalink":"http://yoursite.com/categories/mldl/"}]},{"title":"Alert Window 弹窗控制","date":"2017-08-30T06:56:59.000Z","path":"android/alert-window-权限控制/","text":"aosp-5.1.1_r6 源码分析 1234567891011121314151617181920WMS.addWindow()-&gt; PhoneWindowManager.checkAddPermission() &#123; switch TYPE_SYSTEM_ALERT/TYPE_SYSTEM_OVERLAY/TYPE_SYSTEM_ERROR/TYPE_PHONE/TYPE_PRIORITY_PHONE: permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW (int数值24) if mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED: return WindowManagerGlobal.ADD_PERMISSION_DENIED&#125;-&gt; ContextImpl.checkCallingOrSelfPermission(String permission)-&gt; ContextImpl.checkPermission(permission, Binder.getCallingPid(), Binder.getCallingUid())-binder-&gt; AMS.checkPermission(permission, pid, uid)-&gt; AMS.checkComponentPermission(permission, pid, UserHandle.getAppId(uid), owningUid=-1, exported=true)-&gt; ActivityManager.checkComponentPermission(permission, uid, owningUid, exported) &#123; if uid==0 || uid == Process.SYSTEM_UID: 允许 if UserHandle.isIsolated(uid): 禁止 if owningUid &gt;= 0 &amp;&amp; UserHandle.isSameApp(uid, owningUid): 允许 if !exported: 禁止 if permission == null: 允许 return AppGlobals.getPackageManager().checkUidPermission(permission, uid)&#125; aosp-6.0.0_r1 源码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152WMS.addWindow()-&gt; PhoneWindowManager.checkAddPermission() &#123; switch TYPE_SYSTEM_ALERT/TYPE_SYSTEM_OVERLAY/TYPE_SYSTEM_ERROR/TYPE_PHONE/TYPE_PRIORITY_PHONE: permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW (int数值24) if permission == android.Manifest.permission.SYSTEM_ALERT_WINDOW: mode = mAppOpsManager.checkOp(outAppOp[0], callingUid, attrs.packageName) switch mode == MODE_ALLOWED/MODE_IGNORED 返回 ADD_OKAY. 其中 MODE_IGNORED 会让添加的window在WMS中隐藏 mode == MODE_ERRORED 返回 ADD_PERMISSION_DENIED default: mContext.checkCallingPermission(permission) == PERMISSION_GRANTED&#125;1. AppOpsManager.checkOp(op=outAppOp[0], uid=callingUid, packageName=attrs.packageName)-&gt; AppOpsService.checkOperation(code=op, uid, packageName) &#123; if isOpRestricted(uid, code, packageName): return MODE_IGNORED code = AppOpsManager.opToSwitch(code) UidState uidState = getUidStateLocked(uid, false) if uidState != null &amp;&amp; uidState.opModes != null: uidMode = uidState.opModes.get(code) if uidMode 有设置不是ALLOWED: return uidMode Op op = getOpLocked(code, uid, packageName, false) if op == null: return AppOpsManager.opToDefaultMode(code) else: return op.mode&#125;1.1 AppOpsService.isOpRestricted(uid, code, packageName) &#123; userHandle = UserHandle.getUserId(uid) 多用户时 uid/100000, 否则 0 opRestrictions = mOpRestrictions.get(userHandle) if opRestrictions != null &amp;&amp; opRestrictions[code]: if AppOpsManager.opAllowSystemBypassRestriction(code): ops = getOpsLocked(uid, packageName, true) if ops != null &amp;&amp; ops.isPrivileged: return false return true return false&#125;2. ContextImpl.checkCallingPermission(String permission)-&gt; checkPermission(permission, pid=Binder.getCallingPid(), Binder.getCallingUid())--binder--&gt; AMS.checkPermission(permission, pid, uid)-&gt; ActivityManager.checkComponentPermission(permission, pid, uid, owningUid=-1, exported=true) &#123; appid = UserHandle.getAppId(uid) uid 取模 100000 PackageManager.checkUidPermission(permission, uid)&#125;--binder--&gt; PMS.checkUidPermission(permission, uid) &#123; userId = UserHandle.getUserId(uid) obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid)) if(obj != null): PermissionState permissionState = ((SettingBase)obj).getPermissionState() if permissionState.hasPermission(permName, userId): return PERMISSION_GRANTED else: if mSystemPermissions.get(uid).contains(permName): return PERMISSION_GRANTED&#125;","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"tensorflow rnn embedding","date":"2017-08-30T06:51:58.000Z","path":"mldl/tensorflow-core_rnn_cell-源码分析/","text":"seq2seq 中的 rnn embedding 是 trainable 的12345678910111213141516legacy_seq2seqembedding_attention_seq2seqcore_rnn_cell.py:line111: EmbeddingWrapper.call(self, inputs, state) inputs仍是list(token id) embedding = vs.get_variable(&quot;embedding&quot;, [self._embedding_classes, self._embedding_size], initializer=initializer, dtype=data_type)-&gt; line1135 variable_scope.py: get_variable() # custom_getter=None, use_resource=None, Trainable=True-&gt; line991 variable_scope.py: VariableScope.get_variable( _get_default_variable_store(), name, shape=shape, dtype=dtype, initializer=initializer, regularizer=regularizer, trainable=trainable, collections=collections, caching_device=caching_device, partitioner=partitioner, valid_shape=valid_shape, use_resource=use_resource, custom_getter=custom_getter, constraint=constraint) return var_store.get_variable(full_name, ...) # full_name = self.name + &quot;/&quot; + name-&gt; line225 _VariableStore.get_variable(name, ...) custom_getter == None: return _true_getter()-&gt; line329 _VariableScope.get_variable._true_getter()-&gt; line663 _VariableScope._get_single_variable()-&gt; variables.Variable(trainable=True)","tags":[],"categories":[{"name":"mldl","slug":"mldl","permalink":"http://yoursite.com/categories/mldl/"}]},{"title":"uiautomator 启动流程","date":"2017-06-23T03:59:57.000Z","path":"android/uiautomator-启动流程/","text":"版本: android-6.0.0_r1运行示例1uiautomator runtest AppiumBootstrap.jar -c io.appium.android.bootstrap.Bootstrap -e disableAndroidWatchers false -e acceptSslCerts false shell 脚本 位置 frameworks/base/cmds/uiautomator/cmds/uiautomator/uiautomator 1234基础 CLASSPATH=/system/framework/android.test.runner.jar:$&#123;base&#125;/framework/uiautomator.jar收集 runtest 后跟的所有 jar 添加到 CLASSPATH=$&#123;CLASSPATH&#125;:$&#123;jars&#125;, 设置 args=&quot;$&#123;cmd&#125; 其余参数$&#123;args&#125; -e jars $&#123;jars&#125;&quot;exec app_process /system/bin com.android.commands.uiautomator.Launcher $&#123;args&#125; com.android.commands.uiautomator.Launcher#main() 位置 frameworks/base/cmds/uiautomator/cmds/uiautomator/src/com/android/commands/uiautomator/Launcher.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; Command command = findCommand(args[0]); command.run(args[1:]); &#125;-&gt; command.name()==&quot;runtest&quot;: RunTestCommand.run(args[1:])-&gt; RunTestCommand.run() -&gt; parseArgs() 解析命令行参数 -c com.myapp.myclass 和 -e class com.myapp.myclass 通过 addTestClasses() 加到 mTestClasses -e runner com.myapp.myrunner 设置到 mRunnerClassName -e debug true 设置到 mDebug --monkey 设置到 mMonkey=true -s 设置到 mParams[&quot;outputFormat&quot;]=&quot;simple&quot; 其余放到 mParams map -&gt; if(mTestClasses.isEmpty()) addTestCalssesFromjars() 若命令行没指定test class, 查找 jars 指定的所有dex文件中 继承自 UiAutomatorTestCase 且是 top-level 的类, 加到 mTestClasses -&gt; getRunner().run(mTestClasses, mParams, mDebug, mMonkey) getRunner() 返回 UiAutomatorTestRunner() 或指定的 mRunnerClassName 类实例 -&gt; UiAutomatorTestRunner.run() 设置线程的 defaultUncaughtExceptionHandler 报告给 watcher 并退出 start() 退出 返回0 -&gt; start() 通过 (TestCaseCollector getTestCaseCollector()).addTestClasses(mTestClasses) 添加到 TestCaseCollector.mTestCases 每个 &lt;className, methodName&gt; 一条 启动 UiAutomatorTestRunner.mHandlerThread 线程 daemon 化(防止进程提前退出？) (automationWrapper=new UiAutomationShellWrapper()).connect() 创建 UiAutomationShellWrapper.mHandlerThread 线程 UiAutomationShellWrapper.mUiAutomation = new UiAutomation(ShellWrapper的 looper, new UiAutomationConnection()) 创建 mClient=IAccessibilityServiceClientImpl(ShellWrapper的 looper), UiAutomationConnection 是连接accessibilityService的binder实现?, 提供instrumentation和跨app测试能力 mUiAutomation.connect() 注册到accessibilityManagerService 并sleep循环等待binder回调设置 mConnectionId -&gt; mUiAutomationConnection.connect(mClient) &#123; AccessibilityManager.registerUiTestAutomationService(mToken, client, info) &#125; 以上是与 accessibilityManagerService 连接上的所有步骤 mUiDevice = UiDevice.getInstance(); mUiDevice.initialize(new ShellUiAutomatorBridge(automationWrapper.getUiAutomation())) UiDevice 的初始化 testRunResult.addListener(resultPrinter); foreach mTestListeners: testRunResult.addListener() 添加listener foreach testCases: preapreTestCase(testCase); testCase.run(testRunResult); -&gt; prepareTestCase() testCase.setAutomationSupport((mAutomationSupport=new IAutomationSupport() 负责 sendStatus 给 mWatcher )); testCase.setUiDevice(mUiDevice); testCase.setParams(mParams); finally resultPrinter.print(testRunResult, runTime, testRunOutput); 输出运行结果 automationWrapper.disconnect() 从 accessibilityManagerService 注销 automationWrapper.setRunAsMonkey(false) mHandlerThread.quit() 退出线程, 进程结束 listener/watcher/结果输出 相关123456789101112131415161718192021222324252627282930313233343536* UiAutomatorTestRunner.java * run 线程设置 UncaughtExceptionHandler(): results=new Bundle(); results.putString(); mwatcher.instrumentationFinished(null,0,results); * start() resultPrinter = new WatcherResultPrinter(testCases.size()) 或 mParams 里包含 &quot;outputFormat&quot;:&quot;simple&quot; 时 new SimpleResultPrinter(System.out, true) testRunResult = new TestResult(); testRunResult.addListener(resultPrinter); foreach mTestListeners: testRunResult.addListener(l) 运行测试 foreach testCase: testCase.run(testRunResult) 异常出错时 resultPrinter.printUnexpectedError(Throwable t); testRunOutput.putStirng(&quot;shortMsg&quot;, t.getMessage()); finally resultPrinter.print(testRunResult, runTime, testRunOutput)* UiAutomatorTestRunner.WatcherResultPrinter.print(result, runTime, Bundle testOutput) mPrinter.print(result, runTime, testOutput) WatcherResultPrinter 构造函数中 mStream=new ByteArrayOutputStream(); mWriter=new PrintStream(mStream); mPrinter=new SimpleResultPrinter(mWriter,fullOutput=false) 输出到 ByteArray testOutput.putString(..., mStream.toString()) 输出到bundle中 mWriter.close() mAutomationSupport.sendStatus(RESULT_OK, testOutput) 发送给 watcher * UiAutomatorTestRunner.SimpleResultPrinter.print(result, runTime, testOutput) printHeader(runTime); if(fullOutput): printErrors(result); printFailures(result); printFooter(result);* UiAutomatorTestRunner.WatcherResultPrinter.printUnexpectedError(Throwable t) (getWriter()==mWriter).printf(&quot;...aborted...&quot;); t.printStackTrace(getWriter())* 发送给 mWatcher = new FakeInstrumentationWatcher()FakeInstrumentationWatcher.instrumentationStatus(ComponentName null, int resultCode, Bundle status) mRawMode==false: foreach status.keyValue: System.out.println(...) notifyAll()","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"repo refs/remotes/m 来源分析","date":"2017-04-24T06:30:16.000Z","path":"android/repo-refs-m分析/","text":"refs/remotes/m 是什么m 代表 merge, 是 git 仓库里的 .gitconfig 里 branch 的 merge 字段 refs/remotes/m 怎么来的123456789101112131415161718192021222324252627git_refs.pyR_M = &apos;refs/remotes/m/&apos;使用info.pyInfo.findRemoteLocalDiff(project) 列出remote和local的diff设置/读取project.py Sync_NetworkHalf()-&gt; Project._InitMRef() &#123; self._InitAnyMRef(R_M + self.manifest.branch) 传参 &apos;refs/remotes/m/&apos;+manifests仓库的currentBranch.merge self.revisionId == None: Project的创建在 manifest_xml.py _AddMetaProjectMirror()/_ParseProject() 两处revisionId均为None remote=self.GetRemote(self.remote.name) dst=remote.ToLocal(self.revisionExpr) revisionExpr 顺序: 1.项目的 revision 字段, 2. remote 指定的 revision 字段, 3. default 指定的 revision 字段 参考: https://gerrit.googlesource.com/git-repo/+/master/docs/manifest-format.txt self.bare_git.symbolic_ref(&apos;-m&apos;, msg, ref, dst) 设置symbolic-ref &#125; 设置的ref log可通过 git reflog refs/remotes/m/rBranch 查看-&gt; Project._InitAnyMRef(ref) &#123; self.bare_ref.symref(ref) &#125;-&gt; git_refs.py GitRefs.symref(name) &#123; self._EnsureLoaded(); return self._symref[name] &#125; -&gt; GitRefs._EnsureLoaded() &#123; if self._phyref is None or self._NeedUpdate(): self._LoadAll() &#125; -&gt; GitRefs._LoadAll() &#123; self._ReadPackedRefs() 读取 .git/packed_refs 忽略 # 和 ^ 打头行, foreach 其余每行 ref_id name: self.phyref[name]=ref_id self._ReadLoose(&apos;refs/&apos;) &#123; 递归读取 .git/refs 目录 foreach 文件: _ReadLoose1(self, 文件路径path, 相对.git的文件名称name) &#123; 读取文件 if &apos;ref: &apos;打头: self._symref[name]=ref_id[5:] else: self._phyref[name]=ref_id self._ReadLoose1(os.path.join(self._gitdir, HEAD), HEAD) &#125; 读取 .git/HEAD 也就是说，refs/remotes/m/branchName 会在每次sync时候读取，若没有则创建，不需要自己创建并push到remote","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Torch windows 编译","date":"2017-04-16T14:31:21.000Z","path":"mldl/torch-windows-build/","text":"Prereq VS2015 community conda ( Anaconda / Miniconda ) conda 目录和其 Scripts 子目录加入 path 下载123git clone https://github.com/BTNC/distro-win.gitcd distro-win; git checkout 2f95bf3ac5c6653b12ce7e5db1c8c0564c501b99 # 此次编译成功的版本git submodule update 修改 install-deps.bat 可以注释掉开头对平台的判断, 直接写上要编译的平台, conda env 名称增加平台类型 12345678910111213141516REM if \"%TORCH_VS_PLATFORM%\" == \"x86\" set TORCH_VS_TARGET=x86REM if not \"%TORCH_VS_PLATFORM%\" == \"%TORCH_VS_PLATFORM:_x86=%\" set TORCH_VS_TARGET=x86REM if not \"%TORCH_VS_PLATFORM%\" == \"%TORCH_VS_PLATFORM:_arm=%\" set TORCH_VS_TARGET=armREM if \"%TORCH_VS_TARGET%\" == \"\" set TORCH_VS_TARGET=x64REM 直接设置 x86 或 x64set TORCH_VS_PLATFORM=x86set TORCH_VS_TARGET=x86...REM if \"%TORCH_INSTALL_DIR%\" == \"\" set TORCH_INSTALL_DIR=%TORCH_DISTRO%\\installset TORCH_INSTALL_DIR=%TORCH_DISTRO%\\install...:CONDA_SETUPif \"%TORCH_CONDA_ENV%\" == \"\" set TORCH_CONDA_ENV=torch-vc%CONDA_VS_VERSION%-%TORCH_VS_TARGET% pkg\\torch\\lib\\TH 无法解析的外部符号 _AVX, _AVX2 pkg\\torch\\lib\\TH\\THVector.c 修改 1234567891011#if defined(USE_AVX)/*#include \"vector/AVX.h\"*/#define __AVX__#include \"vector/AVX.c\"#endif#if defined(USE_AVX2)/*#include \"vector/AVX2.h\"*/#define __AVX2__#include \"vector/AVX2.c\"#endif nn 编译报错 fatal error C1001 extra\\nn\\lib\\THNN\\generic\\TemporalRowConvolution.c:126 行 1memcpy 改为 memmove 其他错误 多数 submodule lua pkg 编译/安装错误 可以删除对应 submodule, 重新运行 install-deps.bat 编译1install.bat 测试输入行太长 错误install\\luajit.cmd 按以下注释, 解决 path设置导致的 输入行太长 错误 1REM call %TORCH_INSTALL_DIR%\\torch-activate.cmd 运行测试12install\\torch-activate.cmdtest.bat","tags":[],"categories":[{"name":"mldl","slug":"mldl","permalink":"http://yoursite.com/categories/mldl/"}]},{"title":"SystemUI 最近应用 源码分析","date":"2017-01-04T06:38:43.000Z","path":"android/systemui-recents/","text":"版本: android-6.0.0_r1初始化12345RecentsTaskLoader.initialize() &#123; 初始化 mApplicationIconCache/mThumbnailCache/mActivityLabelCache/mContentDescriptionCache mLoadQueue = new TaskResourceLoadQueue() new TaskResourceLoader(mLoadQueue) &#123;用HandlerThread起LoaderThread, post自身(Runnable)&#125; &#125;&lt;- Recents.start() systemui启动时各模块初始化调用 TaskResourceLoader.mLoadThread 加载线程 逐个加载推到 mLoadQueue的 Task的相关内容 icon/thumbnail/label 加载完调用 (Task t).notifyTaskDataLoaded(thumbnail, icon) 通知更新 加载Task加载所有task每次加载所有task都使用一个 plan 1234567891011121314151. RecentTaskLoader.loadTasks(ctx, plan, opts)opts.numVisibleTasks 控制plan加载时是否加载icon, opts.numVisibleTaskThumbnails 控制plan加载时是否加载thumbnail1.1. &lt;- Recents.start() 最先调用1.2. &lt;- RecentsActivity.updateRecentsTasks() 启动最近应用时调用, 消费Recents.sInstanceLoadPlan &lt;- RecentsActivity.onStart()1.3. &lt;- Recents.preloadIcon() 1.3.1. &lt;- Recents.getThumbnailTransitionActivityOptions() 没有thumbnailTransitionBitmapCache或不匹配时 &lt;- Recents.startRecentsActivity() if(useThumbnailTransition) 获取用来切换acitivity用 1.3.2. &lt;- Recents.preCacheThumbnailTransitionBitmapAsync() &lt;- Recents.preloadRecentsInternal() &#123; 预加载 sInstanceLoadPlan(将来被RecentsActivity消费); if(topTask有变化) preCacheThumbnailTransitionBitmapAsync() &#125; &lt;- Recents.preloadRecents() if user是owner &lt;- BaseStatusBar.preloadRecents() 1.3.2.1 &lt;- BaseStatusBar.mRecentsPreloadOnTouchListener() navBar的最近应用按钮响应 1.3.2.2 &lt;- (Handler H) BaseStatusBar.preloadRecentApps() 用于响应IstatusBar binder调用1.4. &lt;- TaskStackListenerImpl.run() 加载单个task1234567891011122. RecentTaskLoader.loadTaskData(Task t) &#123; requiresLoad = (applicationIcon==null 或 thumbnail==null) if(requiresLoad) mLoadQueue.addTask(t) t.notifyTaskDataLoaded() 先通知更新, 可能为默认图, 后面LoaderThread加载完还有通知&#125;&lt;- TaskStackView.prepareViewToLeavePool(taskView, task, isNewView)&lt;- ViewPool.pickUpViewFromPool()2.1. &lt;- TaskStackView.synchronizeStackViewsWithModel() 2.1.1 TaskStackView.computeScroll() 2.1.2 TaskStackView.onMeasure() &#123; if(mAwaitingFirstLayout) synchronizeStackViewsWithModel() &#125; 2处都是view的函数重载2.2. &lt;- TaskStackViewFilterAlgorithm.getEnterTransformsForFilterAnimation() taskStack 变化监听123456789注册Recents.start() &#123; mSystemServiceProxy.registerTaskStackListener(new TaskStackListenerImpl())&#125;-&gt; SystemServiceProxy.registerTaskStackListener(l) &#123; mIam.registerTaskStackListener(l) &#125;变化TaskStackListenerImpl.onTaskStackChanged() &#123; mHandler.post(this) &#125;--SystemUIService主线程handler--&gt; TaskStackListenerImpl.run() 保存/加载 taskRecord123TaskRecord.saveToXml()TaskRecord.restoreFromXml() &#123; ActivityRecord.restoreFromXml() &#125; 启动12AMS.startActivityFromRecents()-&gt; AMS.startActivityFromRecentsInner() 截屏大小frameworks/base/core/res/res/values-sw720dp/dimens.xml 添加 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;dimen name=\"thumbnail_width\"&gt;1280dp&lt;/dimen&gt; &lt;dimen name=\"thumbnail_height\"&gt;720dp&lt;/dimen&gt;&lt;/resources&gt; 长按启动frameworks/base/core/res/res/values-sw720dp/config.xml 添加 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;integer name=\"config_longPressOnHomeBehavior\"&gt;1&lt;/integer&gt;&lt;/resources&gt; activity 按 back 键所走的流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798按键down: Activity.onKeyDown(keyCode, event) &#123;event.startTracking();&#125;按键up: Activity.onKeyUp(keyCode, event) &#123;event.isTracking(): onBackPressed()&#125;Activity.onBackPressed() -&gt; Activity.finishAfterTransition() -&gt; Activity.finish()-&gt; Activity.finish(finishTask==false) 最后到 mParent==null: ActivityManagerNative.getDefault().finishActivity()--binder--&gt; AMS.finishActivity(token, resultCode, resultData, finishTask==false) &#123; 若同task仍有activity: mController.activityResuming(next.packageName) finishTask==false: (TaskRecord tr).stack.requestFinishActivityLocked(token, resultCode, resultData, &quot;app-request&quot;, true) &#125;-&gt; ActivityStack.finishActivityLocked((当前的 ActivityRecord r), resultCode, resultData, reason, oomAdj) &#123; adjustFocusedActivityLocked(r, &quot;finishActivity&quot;) finishActivityResultLocked(r, resultCode, resultData)&#125; -&gt; ActivityStack.adjustFocusedActivityLocked(ActivityRecord r, String reason) &#123; myReason = reason + &quot; adjustFocus&quot; // 当前stack是frontStack(top或可见), AMS当前焦点activity是r mStackSupervisor.isFrontStack(this) &amp;&amp; (AMS mService).mFocusedActivity == r): ActivityRecord next = topRunningActivityLocked(null) 该stack当前的top task的top running activity, 已排除 finishing r.frontOfTask &amp;&amp; task == topTask() &amp;&amp; task.isOverHomeStack(): if 本stack非全屏: adjustFocusedToNextVisibleStackLocked(null, myReason) 否则 mStackSupervisor.moveHomeStackTaskToTop(task.getTaskToReturnTo(), myReason) 重新设置到AMS ActivityRecord top = mStackSupervisor.topRunningActivityLocked() (AMS mService).setFocusedActivityLocked(top, myReason) &#125;TaskRecord.mTaskToReturnTo 表示task销毁时返回的目标, 有* APPLICATION_ACTIVITY_TYPE=0 返回到 本task 下方的task* HOME_ACTIVITY_TYPE=1 返回到HOME* RECENTS_ACTIVITY_TYPE=2 返回到 recents初始化:field初始化为 APPLICATION_ACTIVITY_TYPE, 默认ctor初始化为 HOME_ACTIVITY_TYPE, voiceInteractor ctor保留field初始化值TaskRecord.setTaskToReturnTo(int)1. &lt;- AMS.moveTaskToFrontLocked(taskId, flags, options) &#123; task = mStackSupervisor.anyTaskForId(taskId); if 当前的 topRunningActivity == 最近应用: task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE) &#125; 总结: moveTaskToFront() 时 设置返回到 最近应用2. &lt;- ActivityStackSupervisor.resumeHomeStackTask(homeStackTaskType, prev, reason) &#123; prev != null: prev.task.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE) &#125;3. &lt;- ASS.startActivityUncheckedLocked() &#123; line:2116 launchFlags &amp; (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_MULTIPLE_TASK) != 0 或 launchSingleInstance 或 launchSingleTask: if(没有要求lauch到某个task &amp;&amp; 没有要result reply) &amp;&amp; 找到已有的task &amp;&amp; 当前 (ActivityRecord curTop) 非空 &amp;&amp; curTop.task != (ActivityRecord 要启动的 intentActivity).task &amp;&amp; (找不到启动来源(sourceRecord == null) || 启动来源是topActivity) &amp;&amp; (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_TASK_ON_HOME) != 0): movedHome = true intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE) 总结: TASK_ON_HOME启动时 设置返回到 HOME&#125;4. &lt;- ASS.startActivityUncheckedLocked() &#123; line:2334 if(!movedHome) &amp;&amp; launchFlags &amp; (NEW_TASK|TASK_ON_HOME) != 0: r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE)&#125; 总结: TASK_ON_HOME启动时 设置返回到 HOME5. &lt;- ASS.startActivityUncheckedLocked() &#123; line:2452 if 启动来源 是 最近应用: r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE)&#125; 总结: 启动来源 是 最近应用 时 设置返回到 最近应用6. &lt;- ASS.findTaskToMoveToFrontLocked() &#123; if flags &amp; ActivityManager.MOVE_TASK_WITH_HOME: task.setTaskToReturnTo(HOME_ACTIVITY_TYPE)&#125;7. &lt;- ActivityStack.resumeTopActivityInnerLocked(prev, bundle) &#123; line:1637 nextTask = topRunningActivityLocked().task if prevTask != nextTask &amp;&amp; prevTask != topTask(): taskNdx = mTaskHistory.indexOf(prevTask) + 1 mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE)&#125; 总结: resumeTopActivity 时 prevTask != topTask 设置prevTask顶上那个task 返回到 HOME8. &lt;- AS.insertTaskAtTop(task, newActivity) &#123; line:2033 if task.isOverHomeStack() &amp;&amp; nextTask != null: nextTask.setTaskToReturnTo(task.getTaskToReturnTo())&#125; 总结: 要插入到top的task 原来的nextTask 也返回到 task.getTaskToReturnTo()9. &lt;- AS.insertTaskAtTop(task, newActivity) &#123; line:2043 if isOnHomeDisplay(): fromHome = lastStack.isHomeStack() 上次焦点stack if !isHomeStack() &amp;&amp; (fromHome || topTask() != task): task.setTaskToReturnTo(fromHome? lastStack.topTask() == null? HOME_ACTIVITY_TYPE : lastStack.topTask().taskType : APPLICATION_ACTIVITY_TYPE) else: task.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE)&#125;10. &lt;- AS.moveTaskToBackLocked(taskId) &#123; line:3751 canGoHome = !tr.isHomeStack() &amp;&amp; tr.isOverHomeStack() if canGoHome: nextTask.setTaskToReturnTo(tr.getTaskToReturnTo())&#125; 总结: if canGoHome 设置 要移动的task 原来的nextTask 返回到 task.getTaskToReturnTo()11. &lt;- AS.moveTaskToBackLocked(taskId) &#123; line:3770 遍历 mTaskHistory, 确保至少有一个task(自身)可以返回到home if(taskNdx == 1): task.setTaskToReturnTo(HOME_ACTIVITY_TYPE)&#125;12. &lt;- AS.moveTaskToBackLocked(taskId) &#123; line:3788 if(prevIsHome || (task == tr &amp;&amp; canGoHome) || (numTasks &lt;= 1 &amp;&amp; isOnHomeDisplay())): taskToReturnTo = tr.getTaskToReturnTo() tr.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE) return mStackSupervisor.resumeHomeStack(taskToReturnTo, null, &quot;moveTaskToBack&quot;)&#125;13. &lt;- AS.removeTask(task, reason, notMoving) &#123; line:4306 if task.isOverHomeStack() &amp;&amp; taskNdx &lt; topTask &amp;&amp; !nextTask.isOverHomeStack(): nextTask.setTaskToRetrunTo(HOME_ACTIVITY_TYPE)&#125; BluetoothControllerImpl问题updateInfo() 调用线程不一致问题 导致的 NPE 分析123456789101112131415BCI.handleConnectionChange()1. &lt;-- BCI.handleUpdateConnectionStates() 1.1 &lt;- (BCI.H BCI.mHandler) MSG_UPDATE_CONNECTION_STATES 1.2 &lt;- (BCI.H BCI.mHandler) MSG_ADD_PROFILE 1.3 &lt;- (BCI.H BCI.mHandler) MSG_REM_PROFILE2. &lt;--handler-- (BCI.H BCI.mHandler) MSG_UPDATE_SINGLE_CONNECTION_STATE 构造函数传入的bgLooper, 即 PhoneStatusBar 传入的 mHandlerThread.getLooper()BCI.updateInfo() 保证 ArrayMap mDeviceInfo 键值对不为null1. &lt;- BCI.handleUpdateBondedDevices() &lt;- (BCI.H BCI.mHandler) MSG_UPDATE_BONDED_DEVICES2. &lt;- BCI.handleUpdateConnectionStates()3. &lt;- BCI.handleUpdateConnectionState() 3.1 &lt;- BCI.handleUpdateConnectionStates() 3.2 &lt;- (BCI.H BCI.mHandler) MSG_UPDATE_SINGLE_CONNECTION_STATE4. &lt;- BCI.Receiver.onReceive() 跑在 receiver 回调线程. BCI.Receiver.ctor() 中 mContext.registerReceiver(this, filter) 指定了在ui主线程 解决mContext.registerReceiver(this, filter, null, mHandler) 指定在handler(bgLooper)线程","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Activity 透明/非透明 转换","date":"2016-12-01T02:16:21.000Z","path":"android/activity-透明非透明-转换/","text":"12345678910111213141516171819202122232425262728293031Activity.convertFromTranslucent() &#123;ActivityManagerNative.getDefault().convertFromTranslucent(mToken)WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, true)&#125;--binder--&gt; ActivityManagerService.convertFromTranslucent() &#123;(ActivityRecord r).changeWindowTranslucency(true)r.task.stack.releaseBackgroundResources(r)mStackSupervisor.ensureActivitiesVisibleLocked(null, 0)mWindowManager.setAppFullscreen(token, true)&#125;-&gt; ActivityStackSupervisor.ensureActivitiesVisibleLocked() &#123;遍历 display, stack ActivityStack.ensureActivitiesVisibleLocked() &#123; behindFullscreen &amp;&amp; r.visible: 影响到的(ActivityRecord r) 根据r.state动作: case RESUMED: mStackSupervisor.mStoppingActivities.add(r); mStackSupervisor.scheduleIdleLocked() &#125;&#125;--IDLE_NOW_MSG--&gt; ActivityStackSupervisor.activityIdleInternelLocked() &#123;ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(true) 从mStoppingActivities取要stop的遍历stops: (ActivityStack stack).stopActivityLocked(r)&#125;-&gt; ActivityStack.stopActivityLocked(r) &#123; r.app.thread.scheduleStopActivity() &#125;-&gt; ApplicationThreadProxy.scheduleStopActivity(r.appToken, r.visible==false, r.configChangeFlags)--binder--&gt; (ActivityThread.ApplicationThread extends ApplicationThreadNative).scheduleStopActivity() &#123; scheduleStopActivity() &#125;--handler STOP_ACTIVITY_HIDE--&gt; ActivityThread.handleStopActivity()-&gt; ActivityThread.performStopActivityInner()-&gt; Activity.performStop()-&gt; Instrumentation.callActivityOnStop() &#123; activity.onStop() &#125;","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"PackageInstaller 中的 动态权限","date":"2016-11-29T02:57:43.000Z","path":"android/package-installer-动态权限/","text":"manifest统计1234567891011121314151617.PackageInstallerActivityaction=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot;category=&quot;android.intent.category.DEFAULT&quot;.permission.ui.GrantPermissionsActivityaction=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot;category=&quot;android.intent.category.DEFAULT&quot;.permission.ui.ManagePermissionsActivityaction=&quot;android.intent.action.MANAGE_PERMISSIONS&quot;action=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot;action=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot;category=&quot;android.intent.category.DEFAULT&quot;receiver=&quot;.permission.model.PermissionStatusReceiver&quot;android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;intent-filter action=&quot;android.intent.action.GET_PERMISSIONS_COUNT&quot; PackageInstallerActivity12入口activityCONFIRM_PERMISSIONS 通过session进来, 记住sessionId, 选择后回调给session mInstaller.setPermissionsResult() GrantPermissionsActivity 应用主动申请权限时出现的授权界面 授权权限按组进行 12341. 初始化 updateDefaultResults() deny all2. devicePolicyManager.getPermissionPolicy() 获取默认permission类型(STATE_DEFAULT运行时/AUTO_DENY/AUTO_GRANT)根据 permissionPlicy 自动授权 AUTO_DENY/AUTO_GRANT 给 non-fixed( !group.isUserFixed() &amp;&amp; !group.isPolicyFixed())类型的权限3. 剩下的STATE_DEFAULT类型更新界面让用户授权 ManagePermissionsActivity12345678action=&quot;android.intent.action.MANAGE_PERMISSIONS&quot;ManagePermissionsFragmentaction=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot;AppPermissionsFragmentaction=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot;PermissionAppsFragment PermissionStatusReceiver12当有 Intent.ACTION_GET_PERMISSIONS_COUNT 广播询问时, 获取对应的package授权权限数量, 广播反馈/packages/apps/Settings 用到","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"ResolverActivity 流程","date":"2016-11-16T07:12:28.000Z","path":"android/resolve-activity/","text":"版本 aosp-5.1.1_r61234567891011ResolverActivity.java ResolveListAdapter.ctor()-&gt; ResolveListAdapter.rebuildList()--binder--&gt; PackageManagerService.queryIntentActivities() &#123; if intent有component, 直接返回component指定的; if intent有packageName, ActivityIntentResolver.queryIntentForPackage() else ActivityIntentResolver.queryIntent()&#125;-&gt;1. (ActivityIntentResolver父类 IntentResolver).queryIntent()-&gt;2. (ActivityIntentResolver父类 IntentResolver).queryIntentForPackage()-&gt; IntentResolver.buildResolveList() 123456789101112131415161718PMS.findPreferredActivity()1. &lt;- PMS.setLastChosenActivity()&lt;- ResolverActivity.onIntentSelected()2. &lt;- PMS.getLastChosenActivity()&lt;- ResolverActivity.rebuildList()3. &lt;- PMS.chooseBestActivity() &#123;findPreferredActivity(intent,resolvedType,flags,query,r0.priority,true==always,false==removeMatches,debug,userId)&#125;&lt;- PMS.resolveIntent()4. &lt;- PMS.getHomeActivities() &#123; list=queryIntentActivities(); return findPreferredActivity(list) 返回NULL表示没有preferred &#125;&lt;--binder-- PM.getHomeActivities()4.1 &lt;- SystemUI SystemServicesProxy.getHomeActivityPackageName() &lt;- SystemUI AlternateRecentsComponent.startRecentsActivity() 最近应用页面4.2 &lt;- ApplicationPackageManager.getHomeActivities() ContextImpl.mPackageManager==ApplicationPackageManager, 实际client端的PackageManager, api公开接口4.3 &lt;- PackageManagerBackupAgent.getPreferredHomeComponent() &lt;- PMBA.onBackup()","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Android debug-hwui-profile","date":"2016-10-18T12:21:32.000Z","path":"android/debug-hwui-profile/","text":"本文目标探索 gpu呈现模式 测量的是什么基本用法原生Settings1Settings -&gt; 开发者选项 -&gt; gpu呈现模式 命令行1setprop debug.hwui.profile visual_bars # false关闭 图形解释1234蓝色: create/update DisplayList紫色: 同步到render thread红色: 将DisplayList转为gl命令调用黄色: cpu等待gpu完成 profile时机4.4.4_r1涉及文件1HardwareRenderer.java 绘制1234567HardwareRenderer.drawProfileData() &#123; mProfileData 数据 for(i=0; i &lt; getFrameCount()*elementCount; i+=elementCount) mProfileShapes[] &lt;- bar条rect drawGraph() 画bar条 drawCurrentFrame() if(当前帧) 加深当前帧的bar条 drawThreadshold() 16ms水平线 dump1234dumpGfxInfo() mProfileData[i] == Draw mProfileData[i+1] == Process mProfileData[i+2] == Execute 统计Draw123456buildDisplayList() startBuildDisplayListProfiling() Trace.traceBegin(TRACE_TAG_VIEW, &quot;getDisplayList&quot;) view.getDisplayList() Trace.traceEnd(TRACE_TAG_VIEW) endBuildDisplayListProfiling() Process12345drawDisplayList() Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;drawDisplayList&quot;) canvas.drawDisplayList() Trace.traceEnd(Trace.TRACE_TAG_VIEW)&lt;- draw() Execute123swapBuffers() sEgl.eglSwapBuffers(sEglDisplay, mEglSurface)&lt;- draw() 6.0.0_r1涉及文件12frameworks/base/libs/hwui/renderthread/CanvasContext.cppframeworks/base/libs/hwui/renderthread/FrameInfoVisualizer.cpp 绘制12345FrameInfoVisualizer::draw() mFrameSource[] 数据 initializeRects() 根据数据设置所有 bar rect(left/right, top=bottom=baseline) drawGraph() &#123; foreach bar: nextBarSegment() 计算bar高度; canvas-&gt;drawRects() &#125; drawThreshold() 16ms水平线 dump12345FrameInfoVisulizer::dumpData() [IntentdedVsync, SyncStart] == Draw [SyncStart, IssueDrawCommandsStart] == Prepare [IssueDrawCommandsStart, SwapBuffers] == Process [SwapBuffers, FrameCompleted] == Execute 流程123456789101112131415ui线程 ThreadedRenderer.java draw() -&gt; nSyncAndDrawFrame()--jni--&gt; nSyncAndDrawFrame()-&gt; RenderProxy::syncAndDrawFrame()-&gt; DrawFrameTask::drawFrame() &#123; postAndWait() 等待render线程完成当前帧 &#125;DrawFrameTask 继承自 RenderTaskrender线程初始化在 RenderProxy::ctor() 中 RenderThread::getInstance(), 是个Looper Thread调用 threadLoop()-&gt; DrawFrameTask::run() &#123; if(canUnblockUiThread) unblockUiThread() 发信号给ui线程 if(canDrawFrame) (CanvasContext context)-&gt;draw() if(!canUnblockUiThread) unblockUiThread()&#125; 统计DrawIntentdedVsync1234567891011FrameInfo.hUiFrameInfoBuilder::setVsync(vsyncTime, intendedVsync)1. &lt;- CanvasContext::doFrame() &#123; setVsync() 标识vsync时间 prepareTree() CanvasContext::draw() &#125;&lt;- RenderThread::dispatchFrameCallbacks()&lt;--queue-- RenderThread::drainDisplayEventQueue()&lt;- RenderThread::threadLoop()2. &lt;- frameworks/base/core/jni android_view_Surface.cpp ContextFactory::draw() SyncStart123CanvasContext::prepareTree() mCurrentFrameInfo-&gt;markSyncStart()&lt;- doFrame() IssueDrawCommandsStart12CanvasContext::draw() mCurrentFrameInfo-&gt;markIssueDrawCommandsStart() SwapBuffers1231. CanvasContext::draw()2. FrameInfoVisualizer::draw() 临时mark当前帧 FrameCompleted1231. CanvasContext::draw()2. FrameInfoVisualizer::draw() 临时mark当前帧","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"aapt 源码分析","date":"2016-09-11T08:42:19.000Z","path":"android/aapt/","text":"概念12Resource Id 32位 = 8(packageId) + 8(typeId) + 16(nameId)ResourceTable.cpp::makeResId() framework-res典型调用1out/host/linux-x86/bin/aapt package -u -x -z --pseudo-localize -M frameworks/base/core/res/AndroidManifest.xml -S device/myvendor/overlay/frameworks/base/core/res/res -S frameworks/base/core/res/res -A frameworks/base/core/res/assets --min-sdk-version 22 --target-sdk-version 22 --product phone --version-code 22 --version-name 5.1.1-2.0.16 -F out/target/common/obj/APPS/framework-res_intermediates/package-export.apk 流程 总体流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140Main.cpp main() &#123; 收集命令行内容到bundle &#125;-&gt; handleCommand(bundle)-&gt; Command.cpp doPackage(bundle) &#123; assets=new AaptAssets(); assets.slurpFromArgs(bundle) 收集所有文件信息 builder = new ApkBuilder(configFilter) if(有资源文件) buildResources(bundle, assets, builder) 收集和编译resource, 生成id assets.applyJavaSymbols() &#123; 决定哪些内容会输出到 R.java 若是framework-res, AaptAssets.mHavePrivateSymbols==false 没有排除任何内容 若是普通应用, 这里排除掉所有framework中定义的私有内容. &#125; writeResourceSymbols(bundle, assets, ...) writeProguardFile(bundle, assets) if(outputAPKFile) addResourcesToBuilder(assets, builder) 生成apk &#125;-&gt; Resource.cpp buildResources() &#123; parsePackage(androidManifestFile) 取包名, revisionCode, minSdk packageType = 命令行 -x==System, --shared-lib==SharedLibrary, --feature-of==AppFeature table = ResourceTable(bundle, assets.getPackage(), packageType) table.addIncludedResources(bundle, assets) applyFileOverlay() 作用于 OVERLAY_SET=drawable/layout/anim/animator/interpolator/transition/xml/raw/color/menu/mipmap, 这些目录若有overlay, 对应文件替换成overlay中的文件(文件整体替换) 对drawable/mipmap preProcessImages() 对OVERLAY_SET makeFileResources(bundle, assets, &amp;table, ...) 编译每个overlay中的values目录里的xml文件 foreach(overlay) compileResourceFile(bundle, assets, file, it.getParams(), overlay=true, &amp;table) table.assignResourceIds() &#123; package.applyPublicTypeOrder() &#123; public类型 的按 Type.mPublicIndex 重新排序(之后的 p.getOrderedTypes() 返回的就是已排序Type) Type.mPublicIndex 通过 addPublic() 的顺序设置, 就是在 values/public.xml 中的定义顺序 &#125; 遍历 p.getOrderedTypes(): 每个type.getOrderedConfigs() 的 entry 生成 attribute 遍历 p.getOrderedTypes(): 每个type.applyPublicEntryOrder() 按 entryId(即资源id中的nameId) 重新排序(之后的 t.getOrderedConfigs() 返回就是已排序ConfigList) 按顺序 ConfigList.setEntryIndex() 按顺序遍历 每个 type中的 ConfigList中的 Entry: entry.assignResouceIds() 赋值bag中每个key的资源id &#125; 编译 layout/anim/animator/interpolator/transition/xml/drawable/color/menu 中的xml文件 compileXmlFile() 编译自动生成的xml 编译manifest 生成最终resource table: table.addSymbols(assets-&gt;getSymbolsFor(&quot;R&quot;)) 按已排序好的 Type 和 ConfigList 添加 symbol 重新flatten, 输出到resources.arsc validate检查一遍&#125;-&gt; ResourceTable.cpp compileResourceFile(*bundle, &amp;assets, ..., *outTable) &#123; 设 symbols = asset.getSymbolsFor(&quot;R&quot;) switch(标签) case &quot;skip&quot;: 跳过 case &quot;eat_comment&quot;: 跳过 case &quot;public&quot;: &#123; 取type,name,id. outTable.addPublic() -&gt; Type.addPublic() Type.mPublicIndex = typeId(即资源id中间8位值) symbols.addNestedSymbol(type, srcPos) symbols.makeSymbolPublic(name, srcPos) &#125; case &quot;public-padding&quot;: 略 case &quot;private-symbols&quot;: 略 case &quot;java-symbol&quot;: 略 case &quot;add-resouce&quot;: 略 case &quot;declare-stylable&quot;: &#123; 取name symbols.addNestedSymbol(&quot;stylable&quot;, srcPos) symbols.addNestedSymbol(name, srcPos) 遍历XML子tag: compileAttribute(file, block, ..., &amp;itemIdent, inStylable==true) symbols.addSymbol(itemIdent, 0, srcPos) &#125; case &quot;attr&quot;: compileAttribute(file, block, myPackage, outTable, outIdent==NULL, inStylable==false) case &quot;item&quot;: 略 case &quot;string&quot;: 略 case &quot;drawable&quot;: curTag=curType=&quot;drawable&quot;, curFormat=TYPE_REFERENCE|TYPE_COLOR case &quot;color&quot;: curTag, curType, curFormat case &quot;bool&quot;/&quot;integer&quot;/&quot;dimen&quot;/&quot;fraction&quot;/&quot;style&quot;/&quot;plurals&quot;: 基本同上 case &quot;bag&quot;: curType=取type, curIsBag=true case &quot;array&quot;: curFormat=parse_flags(取format) case &quot;string-array&quot;: 略 case &quot;integer-array&quot;: 略 对bag/style/plurals/array/string-array/integer-array: curIsBag=true 解释: bag其实就是 自定义枚举集合 的意思 对array/string-array/integer-array: curIsBagReplaceOnOverwrite=true if(curIsBag) outTable.startBag() parseAndAddBag() &#123; outTable.addBag() overlay overwrite==true时, framework已有的可以覆盖, 没有的要用add-resource &#125; else parseAndAddEntry(ResourceTable *outTable) &#123; 对于overlay, 传入的overwrite==true, framework已有的可以覆盖, 没有的要用add-resource outTable.addEntry() 实际添加到ResourceTable中对应 Type 的 (DefaultKeyedVector&lt;String16, sp&lt;ConfigList&gt; &gt; mConfigs).valueFor(entry) &#125; 检查确认每个resource都有 default variant&#125;-&gt; compileAttribute() &#123; attr = PendingAttribute(myPackage, inFile, block, inStylable) 取name, format attr.createIfNeeded(outTable) 取min, max, localization, 若有则 outTable.addBag() 遍历XML子tag: 非 TYPE_ENUM或TYPE_FALGS, 报错 if 第一次: outTable.addBag(bagKey==&quot;^type&quot;, value==type数字, replace==true) outTable.addBag(bagKey==当前enum/flag的name, value==XML value字段, replace==false) appendTypeInfo() outTable.appendTypeComment() &#125;-&gt; PendingAttribute.createIfNeeded() &#123; if(added) return; added = true outTable.addBag(bagKey==&quot;^type&quot;, value==type数字, replace==false) &#125; 可以得出 attr标签 format/min/max/localization 做一个bag, item是自己; 否则 若有子tag, 子tag必须是enum/flag, 做一个bag, 每个子tag做成一个item-&gt; addBag(srcPos, package, type, name, bagParent, bagKey, value, *style, &amp;params, replace, isId, format)&#123; e=ResourceTable::getEntry(package, type, name, srcPos, replace, params) e.addToBag(sourcePos, bagKey, value, style, replace, isId, format) &#125;-&gt; ResouceTable::getEntry(overlay==replace) &#123; Type t=getType(package, type, sourcePos, doSetIndex) t.getEntry(name, sourcePos, config, dotSetIndex, overlay, bundle.autoOverlay) &#125;-&gt; Entry.addToBag(...) &#123; makeItABag(srcPos) 将自己的mType设为 TYPE_BAG item=Item(srcPos, isId, value, style, format) if(已有key): if(!replace) 报错 else mBag.replaceValueFor(key, item) mBag.add(key, item) mBag是Entry成员, 类型是 KeyedVector&lt;String16, Item&gt; &#125; Item 类型有 TYPE_BAG/TYPE_ITEM, 当类型是TYPE_BAG时 mBag 包含当前bag的所有itemResourceTable.cpp compileXmlFile(*bundle, &amp;assets, *table, XMLNode&amp; root, AaptFile&amp; target) &#123; root.assignResouceIds(assets, table) 设置的 id 会在 flatten 时用到 root.parseValues(assets, table) 记录当前解析的xml源码行号&#125; 写到 R.java 的流程1234567891011121314Command.cpp::doPackage() &#123; framework 生成时包名就是自身, 所以 havePrivateSymbols() 为 false &#125;-&gt; Resource.cpp::WriteResourceSymbols(AaptAssets assets, includePrivate=true) &#123; 遍历 assets-&gt;getSymbols(): 这里的symbol就是上面的 addSymbol() 加的 可能不同 类前缀包名/R.java 输出位置 WriteSymbolClass(AaptSymbols symbols)&#125;-&gt; WriteSymbolClass(AaptSymbols symbols) &#123; // framework-res 编译过程中 havePrivateSymbols()==false, 所以下面的遍历没有跳过任何内容 遍历 symbols-&gt;getSymbols() 所有 TYPE_INT32 类型(跳过非 javaSymbol): (AaptSymbolEntry sym).int32Val 遍历 symbols-&gt;getSymbols() 所有 TYPE_STRING 类型(跳过非 javaSymbol): sym.stringVal.string() 遍历 symbols-&gt;getNestedSymbols(), styleableSymbols除外: 递归 WriteSymbolClass() writeLayoutClasses(styleableSymbols) if emitCallback: writeResourceLoadedCallback() &#125; -&gt; 递归调用 WriteSymbolClass","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"PlantUML 基础","date":"2016-09-07T03:12:58.000Z","path":"misc/plantuml基础/","text":"基本框架1234567891011121314151617181920212223242526272829303132333435@startuml&apos;comment/&apos; multilinecomments&apos;/title First Page Title&apos; some diagramnewpage&apos; some other diagram&apos; legend 图注 left/center/rightlegend centerXX Diagramendlegend&apos; note left/left of/right/right of/over Alicenote left: First notenote rightSecond noteend note&apos; == Divider ==/&apos; space|||||45|| == 45px&apos;/@enduml 类图123456789101112131415161718192021222324class Parentclass ChildParent &lt;|-- Child&apos; 同生同死class CompositeChildCompositeChild : Parent strongRefParent *-- CompositeChild&apos; 不同生同死class AggregateChild &#123;Parent gettWeakParent()&#123;static&#125; getStaticField()&#123;abstract&#125; doAbstractMath()&#125;Parent o-- AggregateChildabstract class &quot;Pure Abstract Class within parens&quot;interface IInterfaceclass GenericClass&lt;? extends G&gt;package &quot;My Package&quot; &#123;IInterface ()- Parent&#125; 时序图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849A -&gt; B: -&gt; solidB --&gt; A: --&gt; dashA -&gt;x B: -&gt;xA -&gt;&gt; B: -&gt;&gt;A \\[#blue]- B: \\[#blue]-autonumberA -&gt; B: autonumber1, ||| == space|||autonumber 10A -&gt; B: autonumber 10, ... == delay... Delayed ...autonumber 20 5A -&gt; B: autonumber 20 5-1A -&gt; B: autonumber 20 5-2A -&gt; B: autonumber stop == (should work)A -&gt; B: activate Bactivate BB -&gt; A: deactivate Bdeactivate BA -&gt; C: activate Cactivate CA -&gt; C: destroy Cdestroy Ccreate DA -&gt; D: create D[-&gt; A: [ IncomingA -&gt;]: ] Outgoingparticipant E &lt;&lt; Stereotype &gt;&gt;A -&gt; E: stereotypeparticipant F &lt;&lt; (S,#ADD1B2) Stereotype &gt;&gt;A -&gt; F: Stereotype with colored Spotbox &quot;box #LightBlue&quot; #LightBlueparticipant Eparticipant Fend boxE -&gt; F: box encompassactor Actor1boundary Boundary1control Control1entity Entity1database Database1participant &quot;Long name #red&quot; as L #redL -&gt; L: recursion","tags":[],"categories":[{"name":"misc","slug":"misc","permalink":"http://yoursite.com/categories/misc/"}]},{"title":"Fresco 源码分析","date":"2016-09-07T03:03:58.000Z","path":"android/fresco/","text":"SimpleDraweeView 显示流程1234SDV: SimpleDraweeViewPDCBuilder: PipelineDraweeControllerBuilderADCBuilder: AbstractDraweeControllerBuilderADController: AbstractDraweeController 设置1234567891011SDV.setImageURI() &#123; controller = PDCBuilder.setUri(uri).setOldController(getController()).build() setController(controller)&#125;-&gt; (PDCBuilder 父类 ADCBuilder).buildController() -&gt; PDCBuilder.obtainController() &#123; 清空现在的listeners &#125; -&gt; ADCBuilder.maybeAttachListeners(controller) &#123; 只剩 ADCBuilder.mBoundControllerListeners, 此成员在 ADCBuilder ctor中赋值为null &#125;-&gt; (SDV 父类 DraweeView).setController() -&gt; DraweeHolder.setController() 触发1234567891011121314在 WindowManger系统 SDV.onAttach() 时(SDV 父类 DraweeView).onAttach()-&gt; DraweeView.doAttach() -&gt; DraweeHolder.onAttach() -&gt; DraweeHolder.attachOrDetachController() -&gt; DraweeHolder.attachController() -&gt; AbstractDraweeController.onAttach() -&gt; ADController.submitRequest() &#123; 若cache到, 直接调用 onNewResultInternal(); 若无cache, mDataSource.subscribe(DataSubscriber), 在 onNewResultImpl()调用 onNewResultInternal() 或 onFailureInternal() &#125;-回调-&gt; ADController.onNewResultInternal() &#123; mSettableDraweeHierarchy.setImage(drawable..) isFinished: &#123; getControllerListener().onFinalImageSet() &#125; 否则: &#123; getControllerListener().onIntermediateImageSet() &#125; 获取线程123Fresco.initialize()-&gt; ImagePipelineFactory.initialize(ImagePipelineConfig) &#123; new ImagePipelineFactory() &#125; -&gt; ImagePipelineFactory.ctor() &#123; mThreadHandoffProducerQueue = DefaultExecutorSupplier.mLightWeightBackgroundExecutor &#125; 提交到线程123456789101112131415161718192021222324(父类 ADController).submitRequest()-&gt; PipelineDraweeController.getDataSource() -&gt; PDCBuilder.getDataSourceForRequest() -&gt; ImagePipeline.fetchDecodedImage() -&gt; ImagePipeline.submitFetchRequest() &#123; ClosableProducerToDataSourceAdapter.create() &#125; -&gt; (ClosableProducerToDataSourceAdapter 父类 AbstractProducerToDataSourceAdapter).ctor() -&gt; BitmapMemoryCacheGetProducer.produceResults() -&gt; ThreadHandoffProducer.produceResults() -&gt; ThreadHandoffProducerQueue.addToQueueOrExecute() &#123; mExecutor.execute() &#125; -executor线程-&gt; StatefulProducerRunnable ThreadHandoffProducer.statefulRunnable.onSuccess() -&gt; (BitmapMemoryCacheKeyMultiplexProducer 父类 MultiplexProducer).produceResults() -&gt; MultiplexProducer.startInputProducerIfHasAttachedConsumers() -&gt; BitmapMemoryCacheProducer.produceResults() -&gt; DecodeProducer.produceResults() -&gt; LocalImageProgressiveDecoder.ctor() -&gt; 父类 ProgressiveDecoder.ctor() &#123; JobRunnable 此job被执行时 doDecode() &#125;AbstractDataSource.subscribe() &#123; mDataSourceStatus在ctor赋初始值 IN_PROGRESS: mSubscribers.add(Pair(dataSubscriber, ADController.mUiThreadImmediateExecutor)) shouldNotify==false: 忽略 &#125;JobScheduler","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"fresco","slug":"fresco","permalink":"http://yoursite.com/tags/fresco/"}],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"duilib使用小结","date":"2016-07-07T00:42:42.000Z","path":"misc/duilib使用/","text":"版本: https://github.com/duilib/duilib master 环境: vs2013 基本内容新建空的win32工程 12345678910111213141516171819#include &lt;UILib.h&gt;class CDuiFrameWnd : public WindowImplBase&#123;public: virtual LPCTSTR GetWindowClassName() const &#123; return _T(\"DUIMainFrame\"); &#125; virtual CDuiString GetSkinFile() &#123; return _T(\"duilib.xml\"); &#125; virtual CDuiString GetSkinFolder() &#123; return _T(\"\"); &#125;&#125;;int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)&#123; CPaintManagerUI::SetInstance(hInstance); CDuiFrameWnd duiFrame; duiFrame.Create(NULL, _T(\"DUIWnd\"), UI_WNDSTYLE_FRAME, WS_EX_WINDOWEDGE); duiFrame.CenterWindow(); duiFrame.ShowModal(); return 0;&#125; xml布局duilib.xml 需要同步到exe目录 1&lt;Button name=\"closebtn\" tooltip=\"关闭\" float=\"true\" pos=\"44,5,74,24\" width=\"28\" normalimage=\" file='SysBtn\\CloseNormal.bmp' \" hotimage=\" file='SysBtn\\CloseFocus.bmp' \" pushedimage=\" file='SysBtn\\CloseFocus.bmp' \"/&gt; tooltip=”关闭” 提示文字 float=”true” 绝对定位，其位置由pos属性指定 布局可以 VerticalLayout 为根节点, HorizontalLayout/VerticalLayout 穿插搭配. 某个Layout指定宽高, 可以用同类型做占位填充剩余空间: 1234567&lt;VerticalLayout&gt; &lt;!-- 占位 --&gt; &lt;HorizontalLayout /&gt; &lt;!-- 底部 --&gt; &lt;HorizontalLayout height=\"30\"&gt; &lt;/HorizontalLayout&gt;&lt;/VerticalLayout&gt; 初始化重载 InitWindow: 1234virtual void WindowImplBase::InitWindow()&#123; CEditUI* pEdit = static_cast&lt;CEditUI*&gt;(m_PaintManager.FindControl(_T(\"startMac\")));&#125; 自绘控件TODO 事件消息处理 1方法1: 重载 Notify 1234567891011121314virtual void WindowImplBase::Notify(TNotifyUI&amp; msg)&#123; if( msg.sType == _T(\"windowinit\") ) &#123; &#125; else if( msg.sType == DUI_MSGTYPE_CLICK ) // 对应 _T(\"click\") &#123; if (msg.pSender-&gt;GetName() == _T(\"btnGen\")) &#123;&#125; &#125; else if (msg.pSender-&gt;GetName() == _T(\"btnClose\")) &#123; PostMessage(WM_CLOSE); // 退出 &#125;&#125; 资源增加rc资源文件 xml和图片资源(假设全在根目录下, 不包括子目录)raw直接放在根目录 zipxml 和所有资源 打包成zip, 放在跟目录 12CPaintManagerUI::SetResourcePath(CPaintManagerUI::GetInstancePath());CPaintManagerUI::SetResourceZip(_T(\"res.zip\")); rc资源rawTODO rc资源zip 2rc资源 添加 导入zip, 类型为 ZIPRES 1234virtual UILIB_RESOURCETYPE WindowImplBase::GetResourceType() const&#123; return UILIB_ZIPRESOURCE; &#125;virtual LPCTSTR WindowImplBase::GetResourceID() const&#123; return MAKEINTRESOURCE(IDR_ZIPRES1); &#125; 静态库重编编译 DuiLib项目: 选择对应的 debug/release 版本, 设置为编译静态库, 添加 UILIB_STATIC 预编译宏. 编译出的lib(release版)改名 DuiLib_s.lib(unicode版名 DuiLib_us.lib), 放入Lib目录 12#define UILIB_STATIC#include &lt;UIlib.h&gt; 1234567891011121314151617181920212223242526272829#ifdef UILIB_STATIC#ifdef _DEBUG# ifdef _UNICODE# pragma comment(lib, \"DuiLib_uds.lib\")# else# pragma comment(lib, \"Duilib_ds.lib\")# endif#else# ifdef _UNICODE# pragma comment(lib, \"DuiLib_us.lib\")# else# pragma comment(lib, \"DuiLib_s.lib\")# endif#endif#else#ifdef _DEBUG# ifdef _UNICODE# pragma comment(lib, \"DuiLib_ud.lib\")# else# pragma comment(lib, \"Duilib_d.lib\")# endif#else# ifdef _UNICODE# pragma comment(lib, \"DuiLib_u.lib\")# else# pragma comment(lib, \"DuiLib.lib\")# endif#endif#endif 图标 3exe静态图标: 添加 资源 -&gt; Icon 导入 exe运行图标: duiFrame.create() 之后调用 1duiFrame.SetIcon(IDI_ICON); 添加版本信息添加 资源 -&gt; Version 其他 4设置标题栏区域xml Window节点 caption属性, 指定标题栏区域(top,left,right,bottom) 1&lt;Window size=\"800,600\" caption=\"0,0,0,32\"&gt; 窗口大小调整xml Window节点 sizebox属性, 边缘可调范围 1&lt;Window size=\"800,600\" sizebox=\"4,4,4,4\"&gt; 窗口最小尺寸xml Window节点 mininfo属性 1&lt;Window size=\"800,600\" mininfo=\"600,400\"&gt; 1.duilib-事件处理 ↩2.duilib-zip-rc ↩3.win32-icon ↩4.duilib-misc ↩","tags":[],"categories":[{"name":"misc","slug":"misc","permalink":"http://yoursite.com/categories/misc/"}]},{"title":"Android 构建系统 源码分析","date":"2016-07-02T01:10:10.000Z","path":"android/build-system/","text":"版本 aosp-5.1.1_r6build/envsetup.sh作用: 找 vendorsetup.sh (收集 lunch combo) 设置编译 JAVA_HOME 设置其他shell参数 TARGET_PRODUCT 不包括 TARGET_DEVICE(在product_config.mk定义) TARGET_BUILD_VARIANT TARGET_BUILD_TYPE TARGET_BUILD_APPS 定义快捷命令 lunch croot m mm mmm mma mmma mgrep jgrep sgrep resgrep godir 1234567891011找device和vendor目录下的vendorsetup.sh 并 sourceaddcompletions() 找 sdk/bash_completion 下 [a-z]*.bash 并 source function gettop&#123;&#125; 返回aosp编译根目录 function lunch&#123;&#125; TARGET_PRODUCT=$product TARGET_BUILD_VARIANT=$variant TARGET_BUILD_TYPE=release aosp_strawberry-userdebug 其中 product==aosp_strawberry, variant==userdebug设置shell变量, 如 $ANDROID_BUILD_TOP 调用关系(按先后顺序)123456789101112AndroidProducts.mk&lt;- build/core/product_config.mk 通过 $(get-all-product-makefils) 查找device,vendor下AndroidProducts.mk, 导入 all_product_configsBoardConfig.mk&lt;- build/core/envsetup.mk 通过查找 device,vendor 下 $(TARGET_DEVICE)/BoardConfig.mk 包含进来, 设置到 board_config_mk &lt;- TARGET_DEVICE 在 envsetup.mk 定义 TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE) &lt;- INTERNAL_PRODUCT 在 product_config.mk 定义 INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT)) &lt;- PRODUCT_DEVICE 由不同的 device 位置下定义AndroidBoard.mk&lt;- build/target/board/Android.mk -include $(TARGET_DEVICE_DIR)/AndroidBoard.mk&lt;- TARGET_DEVICE_DIR 在 build/core/envsetup.mk 定义 TARGET_DEVICE_DIR := $(patsubst %/,%,$(dir $(board_config_mk))) 包含关系12345678910111213141516171819$ANDROID_BUILD_TOP/Makefile-&gt; build/core/main.mk 定义 TOPDIR 为空, BUILD_SYSTEM := $(TOPDIR)build/core -&gt; $(BUILD_SYSTEM)/help.mk -&gt; $(BUILD_SYSTEM)/config.mk( 定义 BUILD_XXX 对应的各个mk, 供以后include ) -&gt; $(BUILD_SYSTEM)/envsetup.mk ( 定义 PRODUCT_OUT ) -&gt; $(BUILD_SYSTEM)/product_config.mk -&gt; $(BUILD_SYSTEM)/node_fns.mk -&gt; $(BUILD_SYSTEM)/product.mk -&gt; $(BUILD_SYSTEM)/device.mk -&gt; $(TARGET_PRODUCT)(来自envsetup.sh) 的 AndroidProducts.mk &#123; call product.mk:import-products -&gt; node_fns.mk:import-nodes(间接定义 PRODUCTS==目标mk文件列表, 同时PRODUCTS本身也用作一个前缀) -&gt; _import-nodes-inner -&gt; import-node -&gt; include 定义 INTERNAL_PRODUCT== $(TARGET_PRODUCT)扩展出来的目标mk文件 &#125; -&gt; $(BUILD_SYSTEM)/cleanbuild.mk -&gt; $(BUILD_SYSTEM)/definitions.mk -&gt; $(BUILD_SYSTEM)/dex_preopt.mk -&gt; build/core/pdk_config.mk recovery build/core/Makefile 123456789101112131415公共资源路径recovery_resources_common := $(call include-path-for, recovery)/resinclude-path-for 定义在 pathmap.mk 中 pathmap_INCL默认 recovery_resources_common := $(recovery_resources_common)-xhdpi私有资源路径recovery_resources_private := $(strip $(wildcard $(TARGET_DEVICE_DIR)/recovery/res))编译依赖recovery_resource_deps := $(shell find $(recovery_resources_common) $(recovery_resources_private) -type f)拷贝 recovery 资源$(INSTALLED_RECOVERY_IMAGE_TARGET): $(recovery_binary)... 等 cp -rf $(recovery_resources_common)/* $(TARGET_RECOVERY_ROOT_OUT)/res $(foreach item,$(recovery_resouces_private), cp -rf $(item) $(TARGET_RECOVERY_ROOT_OUT)/) apicheck1apicheck.mk &#123; .PHONY checkapi; droidcore: checkapi &#125; Add-on1234567891011主mk: device/sample/products/sample_addon.mk&lt;- device/sample/products/AndroidProducts.mk&lt;- build/core/product.mk function _find-android-products-files 查找 device, vendor, $(SRC_TARGET_DIR)/product 目录下所有 AndroidProducts.mk &lt;- function get-all-product-makefiles 返回排序好的所有 AndroidProducts.mk 定义的 PRODUCT_MAKEFILES &lt;- build/core/product_config.mk all_product_configs 从中找到对应 product 的 makefile all_product_makefiles 集合所有product的makefile call import-products 导入product的makefile 例: 12345678910device/sample/products/AndroidProducts.mkPRODUCT_MAKEFILES := $(LOCAL_DIR)/sample_addon.mkPRODUCT_PACKAGES := PlatformLibraryClient \\ com.example.android.platform_library \\ libplatform_library_jni依赖 com.example.android.platform_library 来自device/sample/frameworks/PlatformLibrary/Android.mk&lt;- device/sample/frameworks/Android.mk 引入所有子目录mk&lt;- device/sample/Android.mk 引入所有子目录mk 使用到的主mk: build/core/tasks/sdk-addon.mk MODULES 由 fils_to_copy 拷贝到 dest COPY_FILES 由 files_to_copy 拷贝到 dest TARGET_CPU_API对应的img 拷贝到 $(addon_dir_img) 修改 TARGET_CPU_API对应的 source.properties, 拷贝到 $(addon_dir_img) doc_module 拷贝到 $(OUT_DOCS) sdk打包, image打包 1function module-installed-files 查找某个module在out目录安装位置 OverlayTODO Jack12java-to-jack(definitions.mk)&lt;- LOCAL_IS_STATIC_JAVA_LIBRARY 构建static javalib 时候 $(full_classes_jack)的命令 (static_java_library.mk)","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"LibGDX 实现 动态中文/freetype 加载","date":"2015-01-19T06:01:02.000Z","path":"libgdx/dynamic-freetype/","text":"123451. JSON读取Skin.getJsonLoader() -&gt; new Json() -&gt; json.setSerializer() 读json文件size属性, new FreeTypeBitmapFontStub() FreeTypeBitmapFontStub extends BitmapFont FreeTypeBitmapFontStub.data instanceof FreeTypeBitmapFontData 123456782. Label初始化new Label() -&gt; Label.setStyle() &#123; FreeTypeFontManager.isFreeTypeFont(style.font)==true &#123; data.setSize(style.fontSize) new FontInfo(data.getSize()) font = FreeTypeFontManager.getInstance().refresh(style.font==stub, newInfo) &#125; cache = new BitmapFontCache(font) // cache里的 font == 第一次refresh出来的 12345678910111213141516171819203. 更新文字Label.setText() -&gt; Widget.invalidateHierarchy()-&gt; Label.invalidate() &#123; needsLayout=true; sizeInvalid=true &#125;渲染 -&gt; draw() -&gt; Widget.validate() -&gt; Label.layout()-&gt; computeSize() -&gt; cache.requireSequence(text) &#123; FreeTypeFontManager.isFreeTypeFont(this.font) == true: this.font = FreeTypeFontManager.getInstance().refresh(this.font, curFontInfo) &#125;-&gt; FreeTypeFontManager.refresh(font, newInfo) &#123; isStub == false newInfo不含在当前子串里: getFont(newInfo.size)-&gt; (FreeTypeFontGenerator)generator.generateFont(sizePixel, sequence, flip==false)-&gt; FreeTypeFontGenerator.generateData(size, chars, flip, packer==null)-&gt; FreeTypeFontGenerator.generateData(parameter) &#123; parameter.packer == null: ownsAtlas = true data.regions[i] = new TextureRegion(tex=new Texture()) // new出来的texture return data &#125;&#125;","tags":[],"categories":[{"name":"libgdx","slug":"libgdx","permalink":"http://yoursite.com/categories/libgdx/"}]},{"title":"LibGDX skin load 源码分析","date":"2014-09-22T09:35:06.000Z","path":"libgdx/skin-load/","text":"123构造函数里设置 SkinLoaderAssetManager.ctor() &#123; setLoader(Skin.class, new SkinLoader(resolver==new InternalFileHandleResolver())) &#125;-&gt; AssetManager.setLoader(Skin.class, suffix==null, SkinLoader) 123456用户程序调 loadAssetManager.load(fileName, Skin.class)-&gt; AssetManager.load(fileName, Skin.class, parameter==null) &#123; getLoader(Skin.class, fileName); loadQueue.add(new AssetDescriptor(fileName, Skin.class, parameter))&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849用户程序调 finishLoadingAssetManager.finishLoading() &#123; while(!update()) ThreadUtils.yield() &#125;-&gt; AssetManager.update() &#123; nextTask(); updateTask(); &#125;AssetManager.nextTask() &#123; assetDesc = loadQueue.removeIndex(0); addTask(assetDesc) or inc ref &#125;AssetManager.updateTask() &#123; task.update(); addAsset(fileName, type, task.getAsset()) &#125;-&gt; AssetLoadingTask.update() &#123; handleSyncLoader() or handleAsyncLoader() &#125;SkinLoader 是 AsynchronousAssetLoader, 这里会调用 handleAsyncLoader()-&gt; AssetLoadingTask.handleAsyncLoader() &#123; // 执行多次, 因为submit到线程池中, 被调 call(). // SkinLoader.getDependencies() 加入装载 TextureAtlas 的依赖 exec0: dependenciesLoaded == false &amp;&amp; depsFuture == null: depsFuture = (AsyncExecutor executor).submit(this) exec1: dependenciesLoaded == false &amp;&amp; depsFuture.isDone(): dependenciesLoaded = true 可能的exec2: loadFuture == null &amp;&amp; !asyncDone: loadFuture = executor.submit(this) // 会在线程池中执行 AssetLoadingTask.call() -&gt; 即本loader的 loadAsync() 最后的exec: asyncDone: asset = asyncLoader.loadSync(manager, fileName, resolve(loader, assetDesc), params)&#125;SkinLoader.loadSync() &#123; new Skin(atlas).load(file) &#125;-&gt; Skin.load(skinFile) &#123; getJsonLoader().fromJson(Skin.class, skinFile) &#125;-&gt; Json.fromJson(type==Skin.class) &#123; this.readValue(type, null, new JsonReader().parse(file)) &#125;JsonReader.parse(file) &#123; JsonReader.parse(file.reader(&quot;UTF-8&quot;)) &#125;-&gt; JsonReader.parse(Reader reader) -&gt; JsonReader.parse(data, 0, offset)FileHandle.reader(charset) &#123; return new InputStreamReader(read(), charset) &#125;FileHandle.read() &#123; return new FileInputStream(file()) &#125;FileHandle.file() &#123; return java.io.File &#125;Skin.getJsonLoader(skinFile) &#123; return 匿名Json新类 &#125;匿名Json类.readValue(Skin.class, null, jsonData) &#123; jsonData.isString() == false: super.readValue(Skin.class, elementType==null, jsonData)&#125;Json.readValue(Skin.class, elementType==null, jsonData) &#123; jsonData.isObject() == true: typeName == null: className = null serializer = classToSerializer.get(Skin.class) // 在Skin.java匿名类中有SetSerializer serializer.read(this, jsonData, type)&#125;-&gt; 匿名Json类.read() &#123; for(valueMap) readnamedObjects(json, ClassReflection.forName(valueMap.name()), valueMap) &#125;","tags":[],"categories":[{"name":"libgdx","slug":"libgdx","permalink":"http://yoursite.com/categories/libgdx/"}]},{"title":"RecyclerView 源码分析","date":"2014-07-26T09:23:01.000Z","path":"android/recyclerview/","text":"版本: 25.1.0 Scroll调用顺序1234RecyclerView#requestChildFocus()-&gt; RecyclerView#requestChildRectangleOnScreen()-&gt; LayoutManager#requestChildRectangleOnScreen()-&gt; RecyclerView#smoothScrollBy(int, int) 回调添加/删除1addOnScrollListener/removeOnScrollListener (OnScrollListener) 调用ScrollListener.onScrolled()123456789101112&lt;- RecyclerView.dispatchOnScrolled()1. &lt;- RecyclerView.scrollByInternal() 1.1 &lt;- scrollBy(x, y) 1.1.1 &lt;- RV.LayoutManager.requestChildRectangleOnScreen() &#123; dx!=0 || dy!=0 &#125; 1.1.2 &lt;- RV.LayoutManager.performAccessibilityAction() &#123; vScroll != 0 || hScroll != 0 &#125; 1.2 &lt;- RV.onTouchEvent() ACTION_MOVE 触摸移动 1.3 &lt;- RV.onGenericMotionEvent() SOURCE_CLASS_POINTER ACTION_SCROLL 鼠标滚轮2. &lt;- RecyclerView.dispatchLayoutStep3() &#123; dispatchOnScrolled(0,0) &#125; layout引起的 item range changed3. &lt;- RV.ViewFlinger.run() &#123; hresult=LayoutManager.scrollHorizontallyBy(); 线性布局 会调到 LinearLayoutManager.scrollBy() vresult=LayoutManager.scrollVeriticallyBy(); (hresult != 0 || vresult != 0) dispatchOnScrolled() &#125; RV.smoothScrollBy()1-&gt; RV.ViewFlinger.smoothScrollBy() RV.scrollToPosition()1-&gt; LayoutManager.scrollToPosition() onBindViewHolder()1234567891011121314151617181920RV.Adapter.onBindViewHolder(holder, position)1. &lt;- RV.Adapter.onBindViewHolder(holder, position, payloads)2. &lt;- RV.Adapter.bindViewHolder(holder, position) &lt;- RV.Recycler.tryBindViewHolderByDeadline() 前提: 判断 RecyclerPool.willBindInTime() 2.1 &lt;- RV.Recycler.bindViewToPosition() 2.2 &lt;- RV.Recycler.tryGetViewHolderForPositionByDeadline() &lt;- RV.Recycler.getViewForPosition() 2.2.1 &lt;- LayoutState.next() 2.2.2 &lt;- LinearLayoutManager.next() &lt;- LLM.layoutChunk() &lt;- LLM.fill() 2.2.2.1 &lt;- LLM.onLayoutChildren() 2.2.2.1.1 &lt;- RV.dispatchLayoutStep2() &lt;- 2.2.2.1.1.1 RV.dispatchLayout() &lt;- RV.onLayout() # 一般调用位置 &lt;- 2.2.2.1.1.2 RV.onMeasure() 只在 LayoutManager.setAutoMeasureEnabled(true) 2.2.2.1.2 &lt;- RV.dispatchLayoutStep1() 2.2.2.2 &lt;- LLM.layoutForPredictiveAnimations() 2.2.2.3 &lt;- LLM.scrollBy() 2.2.2.4 &lt;- LLM.onFocusSearchFailed() 版本: 23.0.1 从notifyDatasetChanged() 到实际的view被重新添加和layout12345678问题:什么时候加进动画?Adapter.notifyDataSetChanged() &#123; (AdapterDataObservable mObservable).notifyChanged() &#125; 每个 Observable.onChanged()-&gt; RecyclerViewDataObserver.onChanged() &#123; setDataSetChangedAfterLayout() 每个没有shouldIgnore的viewHolder(现有的和mRecycler的) 添加 FLAG_ADAPTER_POSITION_UNKNOWN if(没有pendingUpdates) requestLayout()--UI Handler下一次处理--&gt; RV.onLayout() -...-&gt; onBindViewHolder()&#125; notifyItemRemoved(pos) 到实际的view被删除和重新layout1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Adapter.notifyItemRemoved(pos) &#123; mObservable.notifyItemRangeRemoved(pos,1) &#125; 每个 Oberservable.onItemRangeRemoved()-&gt; RecyclerViewDataObserver.onItemRangeRemoved() &#123; AdapterHelper.onItemRangeRemoved()一般==true: 加到AdapterHelper.mPendingUpdates数组 triggerUpdateProcessor() &#125;-&gt; RecyclerViewDataObserver.triggerUpdateProcessor() &#123; 一般mHasFixedSize==false: mAdapterUpdateDuringMeasure=true; requestLayout() &#125;--UI Handler下一次处理--&gt; RV.onMeasure() &#123; mAdapterUpdateDuringMeasure==true: ... processAdapterUpdatesAndSetAnimationFlags(); ... mLayout.onMeasure() &#125; -&gt; RV.processAdapterUpdatesAndSetAnimationFlags() &#123; ... mItemAnimator != null &amp;&amp; mLayout.supportsPredictiveItemAnimations(): mAdapterHelper.preProcess(); .. &#125; -&gt; AdapterHelper.preProcess() -&gt; AdapterHelper.applyRemove(op) &#123; type==POSITION_TYPE_NEW_OR_LAID_OUT: postponeAndUpdateViewHolders(op) &#125; -&gt; AdapterHelper.postponeAndUpdateViewHolders(op) &#123; 加到mPostponedList; (RV内部匿名实例 mCallback).offsetPositionsForRemovingLaidOutOrNewView() &#125; -&gt; RV.offsetPositionRecordsForRemove(posStart, count, false); RV.mItemsAddedOrRemoved=true -&gt; &#123; holder.flagRemovedAndOffsetPosition(); mRecycler.offsetPositionRecordsForRemove(); requestLayout() &#125; -&gt; Recycler.offsetPositionRecordsForRemove() -&gt; Recycler.recycleCachedViewAt(idx) &#123; addViewHolderToRecycledViewPool(); mCachedViews.remove(idx) &#125; -&gt; 设置 animationTypeSupported=true; 设置 mState.mRunSimpleAnimations=true; mState.mRunPredictiveanimations=true -&gt; RV.onLayout() -&gt; RV.dispatchLayout() &#123; processAdapterUpdatesAndSetAnimationFlags(); ... mLayout.onLayoutChildren(); 可能修改 mState.mRunSimpleAnimations if(mState.mRunSimpleAnimations) &#123; ... animateDisappearance(disappearingItem) 每个disappearing and removed item animateAppearance(itemHolder) 每个appearing and added item animateMove(postHolder) 每个persistent item animateChange(oldHolder) 每个changing item &#125; -&gt; RV.animateDisappearance(holder) &#123; addAnimatingView(holder) if(没有真的移除) mItemAnimator.animateMove()==true: postAnimationRunner() else(真的移除) holder.setIsRecyclable(fasle); mItemAnimator.animateRemove()加到mPendingRemovals==true: postAnimationRunner() &#125; -&gt; addAnimatingView() &#123; mRecycler.unscrapView(holder); 一般 mChildHelper.hide(view) &#125; -&gt; ChildHelper.hide() -&gt; ChildHelper.hideInternal(view) &#123; 加到 mHiddenViews &#125; -&gt; postAnimationRunner() &#123; 动画runnable post到choreographer上 &#125; &#125;--choreographer下一帧--&gt; 执行动画 RV.mItemAnimatorRunner-&gt; DefaultItemAnimator.runPendingAnimations() &#123; animateRemoveImpl(每个removed的holder); ... &#125;-&gt; DefaultItemAnimator.animateRemoveImpl() &#123; view.animate().alpha(0).setDuration(默认120ms).start() &#125;--动画执行完--&gt; 动画回调 onAnimatinoEnd() &#123; view.setalpha(1); dispatchRemoveFinished(holder); dispatchFinishedWhenDone() &#125; -&gt; (DefaultItemAnimator 父类 ItemAnimator).dispatchRemoveFinished() &#123; mListener.onRemoveFinished() &#125; -&gt; RV.(ItemAnimatorRestoreListener mItemAnimatorListener).onRemoveFinished() &#123; item.setIsRecyclable(true); removeAnimatingView(view) 或 removeDetachedView(view) &#125; -&gt; RV.removeAnimatingView(view) &#123; mChildHelper.removeViewIfHidden(view); if(removed): mRecycler.unscrapView(); mRecycler.recycleViewHolderInternal() &#125; -&gt; ChildHelper.removeViewifHidden() &#123; 从mBucket移除; unhideViewInternal(view); (mCallback==RV匿名).removeViewAt(idx) 真正从RV移除 &#125; -&gt; ChildHelper.unhideViewInternal() &#123; 从 mHiddenViews 移除 &#125;","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Android 启动流程 源码分析","date":"2013-11-23T08:10:00.000Z","path":"android/startup-routines/","text":"版本 android-4.3_r2.2涉及到的文件 /system/core/init/init.c /system/core/init/init_parser.c init_parse_config_file() /system/core/rootdir/init.rc /frameworks/base/cmds/app_process/app_main.cpp LOCAL_MODULE:= app_process /dalvik/vm/Jni.cpp JNI_CreateJavaVM() /dalvik/vm/Init.cpp dvmStartup() init12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152main() &#123; init_parse_config_file(&quot;/init.rc&quot;); execute_one_command(); &#125;-&gt; init_parse_config_file() 读init.rc, 按顺序读入:* ueventd /sbin/ueventd** class core* [optional]console /system/bin/sh** class core* [optional]adbd /sbin/adbd** class core* servicemanager /system/bin/servicemanager** class core* vold /system/bin/vold** class core* netd /system/bin/netd** class main* debuggerd /system/bin/debuggerd*class main* ril-daemon /system/bin/rild** class main* surfaceflinger /system/bin/surfaceflinger** class main* zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server** class main** socket zygote stream 660 root system** 本篇主要分析这个* drm /system/bin/drmserver** class main* media /system/bin/mediaserver** class main* [optional]bootanim /system/bin/bootanimation** class main等内容.-&gt; init.rc 读到on boot ... class start core class_start mainon 是一个 SECTION, parse_new_section(), 此SECTION下的每行 state.parse_line() 就是调的 parse_line_action().class_start 是一个 COMMAND, symbol是 K_class_start(keywords.h用宏拼接出来)zygote服务有 class main. 在 init.c::main() 中通过action_for_each_trigger(&quot;boot&quot;, action_add_queue_tail) 加入到 init_parser.c::action_queue 队列.最后通过 init.c::main() 中 execute_one_command() 从队列中取出执行-&gt; builtins.c::do_class_start()-&gt; service_for_each_class(args[1], service_start_if_not_disabled)-&gt; service_start_if_not_disabled()-&gt; service_start() &#123; fork(); if(pid==0) create_socket(&quot;zygote&quot;, stream, 660, root, system); publish_socket(); app_process的环境变量增加 ANDROID_SOCKET_zygote=&quot;/dev/socket/zygote&quot; &#125; Zygote(app_process进程)1234567891011121314151617181920212223main() &#123; parentDir &lt;= &quot;/system/bin&quot; if(&quot;--zygote&quot;) (AppRuntime runtime).start(&quot;com.android.internal.os.ZygoteInit&quot;, &quot;--startSystemServer&quot;? flag); else runtime.start(&quot;com.android.internal.os.RuntimkeInit&quot;, &quot;--application&quot; or tool? flag); &#125;-&gt; AppRuntime父类 AndroidRuntime::start() &#123; startVm(&amp;mJavaVM, &amp;env); onVmCreated(env); startReg(env); JNI调java的main(), 当前线程作为VM主线程, 直到VM退出. &#125; -&gt; AndroidRuntime::startVm() -&gt; JNI_CreateJavaVM() &#123; memset((DvmGlobals gDvm), 0); calloc (JavaVMExt *pVM); dvmCreateJNIEnv(); dvmStartup(); &#125; -&gt; dvmCreateJNIEnv() &#123; calloc (JNIEnvExt *newEnv); dvmSetJniEnvThreadId(newEnv, self); &#125; -&gt; dvmStartup() &#123; processOptions() &quot;-Xzygote&quot;设置 gDvm.zygote; if(gDvm.zygote) initZygote() else dvmInitAfterZygote(); &#125;--JAVA--&gt; ZygoteInit#main() &#123; registerZygoteSocket(); preload(); gc(); if(&quot;start-system-server&quot;) startSystemServer(); 无限循环runSelectLoop(); &#125; -&gt; registerZygoteSocket() JAVA端用上 create_socket() 出来的 UNIX Domain socket, 作为server端. -&gt; preload() &#123; preloadClasses(); &quot;preloaded-classes&quot;文件每行 #ClassName 调用 Class.forName() preloadResources(); &#125;-&gt; startSystemServer() &#123; Zygote.forkSystemServer(); 最后调的是 dalvik_system_Zygote.cpp::Dalvik_dalvik_system_Zygote_forkSystemServer() if(pid==0) handleSystemServerProcess() &#125; System Server(app_process子进程)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101--SystemServer进程--&gt; handleSystemServerProcess()-&gt; RuntimeInit#zygoteInit() &#123; redirectLogStreams(); 重定向System.out和System.err到logcat系统. commonInit(); nativeZygoteInit(); applicationInit(); &#125; --JNI--&gt; nativeZygoteInit() -&gt; AndroidRuntime.cpp::com_android_internal_os_RuntimeInit_nativeZygoteInit() -&gt; app_main.cpp AppRunTime::onZygoteInit() &#123; (ProcessState proc)-&gt;startThreadPool() &#125; -&gt; ProcessState.cpp::spawnPooledThread(true) &#123; t=new PoolThread(isMain==true); // mCanCallJava默认为true // android_atomic_add()等类似函数返回操作之前的数 t-&gt;run(&quot;Binder_1&quot;, 默认priority==PRIORITY_DEFAULT, 默认stack==0) &#125; --新线程--&gt; _threadLoop() -&gt; PoolThread::threadLoop() -&gt; IPCThreadState::joinThreadPool() // ioctl &quot;/dev/binder&quot; 加入Binder线程池, 无限阻塞获取并执行binder驱动发过来的命令 -&gt; applicationInit() -&gt; invokeStatkcMain(&quot;com.android.server.SystemServer&quot;, startArgs) // args在 ZygoteInit#startSystemServer() -&gt; throw new ZygoteInit.MethodAndArgsCaller(m, argv) 抛异常方式扔掉初始化时多余的栈, 在ZygoteInit#main()捕捉 -&gt; ZygoteInit#main caller.run()-&gt; SystemServer#main() &#123; loadLibrary(&quot;android_servers&quot;); init1(); &#125; -&gt; init1() --JNI--&gt; android_server_SystemServer_init1() --C++--&gt; system_init.cpp::system_init() &#123; defaultServiceManager(); // handle==0 JNI调 SystemServer#init2(); ProcessState::startThreadPool(), joinThreadPool(默认isMain==true); &#125; -&gt; SystemServer#init2() --新线程--&gt; ServerThread#run() &#123; uiHandlerThread = new HandlerThread(); // 起UI线程 wmHandlerThread = new HandlerThread(); // 起WM线程 context = ActivityManagerService.main(); 起各个service: wm = WindowManagerService.main(context, power, display, inputManager, ...); ServiceManager.addService(Context.WINDOW_SERVICE, wm); ActivityManagerService.self().setWindowManager(wm); wm.displayReady(); ... ActivityManagerService.self().systemReady(runnable调各个service.systemReady); // AMS准备完毕 &#125; -&gt; ActivityManagerService#main() &#123; thr = new AThread(); thr.start(); // 新起Looper用线程: 创建AMS, looper.loop() (ActivityThread at) = ActivityThread.systemMain(); // 本线程本Looper管理Acitivty生命周期 (ActivityManagerService m).mMainStack = new ActivityStack(m, context==at.getSystemContext(), true, thr.mLooper); m.startRunning(); &#125; -&gt; ActivityThread#systemMain() &#123; thread=new ActivityThread(); thread.attach(system==true); &#125; -&gt; ActivityThread#attach() &#123; system==true: context=new ContextImpl(); context.init(); app=newApplication(Application.class, context); mAllApplications.add(app); mInitialApplication=app; app.onCreate(); &#125; -&gt; WMS#displayReady() &#123; displayReady(Display.DEFAULT_DISPLAY); mDisplayReady = true; mIsTouchDevice = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN); (mPolicy 就是 PhoneWindowManager).setInitialDisplaySize(...); &#125; -&gt; WMS#displayReady(DEFAULT_DISPLAY) &#123; DisplayContent displayContent = getDisplayContentLocked(DEFAULT_DISPLAY); mAnimator.addDisplayLocked(displayId); &#125; -&gt; WMS#getDisplayContentLocked(DEFAULT_DISPLAY) &#123; Display display = mDisplayManager.getDisplay(DEFAULT_DISPLAY); displayContent = newDisplayContentLocked(display); &#125; -&gt; DisplayManager#getDisplay(DEFAULT_DISPLAY) &#123; DisplayManager#getOrCreateDisplayLocked(DEFAULT_DISPLAY, false); &#125; -&gt; WMS#newDisplayContentLocked(display) &#123; displayContent = new DisplayContent(display); mDisplaySettings.getOverscanLocked(info.name, rect); mDisplayManagerService.setOverscan(display.getDisplayId(), rect...); (mPolicy 就是 PhoneWindowManager).setDisplayOverscan(displayContent.getDisplay(), rect...); &#125; -&gt; AMS#systemReady(goingCallback) &#123; goingCallback.run(); mMainStack.resumeTopActivityLocked(null); &#125; -&gt; ActivityStack#resumeTopActivityLocked(null) -&gt; resumeTopActivityLocked(prev==null, options==null) &#123; next==null: mService.startHomeActivityLocked() &#125; -&gt; ActivityServiceManager#startHomeActivityLocked() -&gt; ActivityStack#startActivityLocked(caller==null, intent, resolvedType==null, aInfo==Launcher信息, resultTo==null, resultWho==null, requestCode==0, callingPid==0, callingUid==0, callingPackage==null, startFlags==0, options==null, componentSpecified==false, outActivity==null) -&gt; startActivityUncheckedLocked(r==new ActivityRecord(), sourceRecord==null, startFlags==0, doResume==true, options==null) -&gt; startActivityLocked(r, newTask==true, doResume==true, keepCurTransition==false, options==null) &#123; mHistory.size() == 0: mService.mWindowManager.addAppToken(addPos==0 ...); doResume==true: resumeTopActivityLocked(null); &#125; -&gt; resumeTopActivityLocked(null) -&gt; resumeTopActivityLocked(prev==null, options==null) &#123; (ActivityRecord next)==Launcher (ProcessRecord next.app)==null: startSpecificActivityLocked(next, andResume==true, checkConfig==true) &#125; -&gt; startSpecificActivityLocked() &#123; getProcessRecordLocked()==null: mService.startProcessLocked(); &#125; -&gt; AMS#startProcessLocked(r.processName, r.info.applicationInfo, knownToBeDead==true, intentFlags==0, hostingType==&quot;activity&quot;, r.intent.getComponent(), allowWhileBooting==false, isolated==false) &#123; getProcessRecordLocked()==null: app=newProcessRecordLocked(null, info, processName, isolated==false) startProcessLocked(app, hostingType==&quot;activity&quot;, hostingNameStr) &#125; -&gt; startProcessLocked() &#123; startResult=Process.start(&quot;android.app.ActivityThread&quot;, ...) &#125; -&gt; Process#startViaZygote(processClass==&quot;android.app.ActivityThread&quot;, ...) -&gt; Process#zygoteSendArgsAndGetResult() &#123; Binder命令zygote(app_process) fork新进程 &#125; Launcher应用123456789101112131415161718--新进程Launcher--&gt; ZygoteConnection#handleChildProc()-&gt; ZygoteInit#invokeStaticMain()--抛异常方式回调--&gt; ActivityThread#main() &#123; thread=new ActivityThread(); thread.attach(false); sMainHandler=thread.getHandler(); Looper.loop(); &#125;-&gt; ActivityThread#attach(system==false) &#123; mgr=ActivityManagerNative.getDefault(); mgr.attachApplication(ApplicationThread mAppThread); &#125;--Binder--&gt; ActivityManagerNative#attachApplication(app)-&gt; 子类AMS#attachApplication(app)-&gt; AMS#attachApplicationLocked() &#123; ActivityRecord hr=mMainStack.topRunningActivityLocked(); hr!=null &amp;&amp; normalMode, hr.app==null: mMainStack.realStartActivityLocked(hr, app, true, true); &#125; -&gt; ActivityStack#realStartActivityLocked() &#123; app.thread.scheduleLaunchActivity(intent, appToken, ...); &#125;--Binder--&gt; Launcher进程 ApplicationThread#scheduleLaunchActivity()-&gt; queueOrSendMessage(H.LAUNCH_ACTIVITY, r)--Handler H--&gt; ActivityThread#handleLaunchActivity(r, null) &#123; performLaunchActivity(); handleResumeActivity(); &#125;","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Node.js Crypto模块 使用示例","date":"2013-11-14T09:44:00.000Z","path":"nodejs/crypto模块使用/","text":"目录 {:toc} Node版本: v0.10.20 (API Stability: 2 - Unstable) 1公钥私钥的签名和验证用 ssh 的公私钥做例子。 ssh-keygen 可以生成不同种类和长度的公私钥对。 查看 ssh key 的种类和长度 3 : 1ssh-keygen -l -f id_rsa.pub # 假设输出长度是 1024 , 种类是 RSA 将 ssh格式 的公钥转换为 RFC4716/PKCS8/PEM 等格式 4 ： 1ssh-keygen -f id_rsa.pub -e -m PEM # 假设保存到 id_rsa.pub.pem 123456789101112131415// 准备公私钥和数据var privatekey = fs.readFileSync('.ssh/id_rsa', 'utf8');var publickey = fs.readFileSync('.ssh/id_rsa.pub.pem', 'utf8');var data = 'www.youku.com';// 用私钥签名var signer = crypto.createSign('RSA-SHA256');signer.update(data);var signature = signer.sign(privatekey, 'base64');// 用公钥验证var verifier = crypto.createVerify('RSA-SHA256');verifier.update(data);var isok = verifier.verify(publickey, signature, 'base64');console.log(isok); // true 加密和解密2用 aes256 算法做例子, 输入字符串为utf-8编码, 加密输出base64编码串. 1234567891011121314151617// 准备密码和数据var algo = 'aes256'var plain_format = 'utf8';var crypt_format = 'base64';var key = '123456';var data = 'secret string';// 加密var cipher = crypto.createCipher(algo, key);var encrypted = cipher.update(data, plain_format, crypt_format);encrypted += cipher.final(crypt_format);// 解密var decipher = crypto.createDecipher(algo, key);var decrypted = decipher.update(encrypted, crypt_format, plain_format);decrypted += decipher.final(plain_format);console.log(decrypted); // 'secret string' 1.Node.js Manual &amp; Documentation ↩2.StackOverflow ↩3.prefetch.net ↩4.unix.stackexchange.com ↩","tags":[],"categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}]},{"title":"Android 窗口系统 源码分析","date":"2013-11-07T07:20:00.000Z","path":"android/window-system/","text":"版本 android-4.3_r2.2涉及到的文件SystemServer进程应用进程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849承接 anatomy-of-android-startup-routines:ActivityThread#handleLaunchActivity(r, null) &#123; performLaunchActivity(); handleResumeActivity(); &#125;-&gt; ActivityThread#performLaunchActivity() &#123; activity = newActivity(); Application app=makeApplication(); appContext = createBaseContextForActivity(); activity.attach(appContext, this, ..., app, ...); mInstrumentation.callActivityOnCreate(activity, r.state); // activity.performCreate() -&gt; activity.onCreate(); if(!r.activity.mFinished): activity.performStart(); if(!r.activity.mFinished &amp;&amp; r.state!=null): mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); if(!r.activity.mFinished): mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; -&gt; Instrumentation#newActivity() &#123; ClassLoader.loadClass(className).newInstance(); &#125; -&gt; LoadedApk#makeApplication() &#123; // 创建Application类的Context ContextImpl appContext=new ContextImpl(); appContext.init(this, null, mActivityThread); (Application app)=mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); appContext.setOuterContext(app); instrumentation.callApplicationOnCreate(app); &#125; -&gt; ContextImpl#类装载时 static &#123; registerService(WINDOW_SERVICE 等各种service); &#125; -&gt; ActivityThread#createBaseContextForActivity(r, activity) &#123; ContextImpl appContext = new ContextImpl(); appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity;); baseContext=appContext; if(没有&quot;debug.second-display.pkg&quot;属性) return baseContext; &#125; -&gt; Activity#attach() -&gt; Activity#attach(context==ContextImpl appContext, ...) &#123; attachBaseContext(context); // mBase==appContext mFragments.attachActivity(this, mContainer, null); (Window mWindow) = PolicyManager.makeNewWindow(this); // 得到 Window 子类 PhoneWindow mWindow.setCallback(this); mUiThread = Thread.currentThread(); mMainThread = 参数 ActivityThread aThread; mWindow.setWindowManager(getSystemService(WINDOW_SERVICE)); mWindowManager = mWindow.getWindowManager(); // 取到WindowManagerImpl &#125; -&gt; PolicyManager#makeNewWindow() &#123; (com.android.internal.policy.impl.Policy sPolicy).makeNewWindow(); &#125; -&gt; Policy#makeNewWindow() &#123; return new PhoneWindow(context); &#125; // extends Window. mWindowAttributes = new WindowManager.LayoutParams(); -&gt; (Window PhoneWindow父类)#setWindowManager(wm, appToken, appName, hardwareAccelerated) &#123; wm!=null: mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); // PhoneWindow 作为本进程所有Window的parent &#125; -&gt; WindowManagerImpl#createLocalWindowManager(parentWindow) &#123; return new WindowManagerImpl(mDisplay, parentWindow); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149ActivityThread#handleResumeActivity(r.token, clearHide==false, r.isForward==false, reallyResume = (!r.activity.mFinished &amp;&amp; !r.startsNotResumed) == true) &#123; ActivityClientRecord r = performResumeActivity(token, clearHide==false); Activity a = r.activity; r.window==null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible: r.window = r.activity.getWindow(); // 就是 PhoneWindow decor = r.window.getDecorView(); decor.setVisibility(INVISIBLE); a.mDecor = decor; if(a.mVisibleFromClient==初始化为true): a.mWindowAdded=true; WindowManager.LayoutParams l = r.window.getAttributes(); l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= (forwardBit==0); (WindowManagerImpl wm).addView(decor, l); if(!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor!=null &amp;&amp; !r.hideForNow): r.activity.mVisibleFromServer = true; if(r.activity.mVisibleFromClient) r.activity.makeVisible(); if(!r.onlyLocalRequest) Looper.myQueue().addIdleHandler(new Idler()); if(reallyResume) ActivityManagerNative.getDefault().activityResumed(token);&#125; -&gt; performResumeActivity() &#123; if!(r.activity.mFinished) r.activity.performResume(); &#125; -&gt; Activity#performResume() &#123; performRestart(); // mStopped==false: pass mInstrumentation.callActivityOnResume(this); // activity.mResumed=true; activity.onResume() mFragments.dispatchResume(); onPostResume(); &#125; -&gt; PhoneWindow#getDecorView() &#123; if(mDecor==null) installDecor(); return mDecor; &#125; -&gt; installDecor() &#123; if(mDecor==null) mDecor=generateDecor(); &#125; -&gt; generateDecor() &#123; return new DecorView(getContext(), featureId==-1); &#125; // PhoneWindow.DecorView extends FrameLayout implements RootViewSurfaceTaker -&gt; WindowManagerImpl#addView() -&gt; (单实例WindowManagerGlobal mglobal)#addView(view==DecorView decor, params, display, parentWindow==PhoneWindow) &#123; root = new ViewRootImpl(view.getContext(), display); view 加到 mViews[], root 加到 mRoots[]. (ViewRootImpl root).setView(view, wparams==params, panelParentView 非SUB_WINDOW类==NULL); &#125; -&gt; ViewRootImpl#ctor() &#123; mSurface = new Surface(); // 空surface, 以后通过 readFromParcel() 填充 mWindowSession = WindowManagerGlobal.getWindowSession(); mThread = Thread.currentThread(); mWindow = new W(this); // W extends IWindow.Stub mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); mChoreographer = Chogreographer.getInstance(); loadSystemProperties(); &#125; -&gt; WindowManagerGlobal#getWindowSession() &#123; if(sWindowSession==null): windowManager = getWindowManagerService() &#123; sWindowManagerService = BinderProxy端 ServiceManager.getService(&quot;window&quot;); &#125; sWindowSession = windowManager.openSession( (单实例InuptMethodManager imm).getClient(), imm.getInputContext() ); // BinderProxy端 IWindowSession, systemServer进程的WMS线程增加一个 Session. return sWindowSession; &#125; --systemServer进程的WMS所在线程--&gt; WMS#openSession() &#123; new Session(service==WMS, ...); &#125; -&gt; Session#ctor() &#123; mService.mInputMethodManager.addClient( InputMethodClient client, inputContext, mUid==应用的Uid, mPid==应用的Pid); &#125; -&gt; ViewRootImpl#setView(view==DecorView decor, attrs=wparams, panelParentView==NULL) &#123; mView == null: mView = decor; view instanceof RootViewSurfaceTaker: mSurfaceHolderCallback = ((RootViewSurfaceTaker)view).willYouTakeTheSurface(); // == null mSurfaceHolder == null: enableHardwareAcceleration(decor.getContext(), attrs); mAdded = true; requestLayout(); mWindowAttributes.inputFeatures==0: mInputChannel = new InputChannel(); (Session mWindowSession).addToDisplay(mWindow, mSeq==0, mWindowAttributes==attrs, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel); &#125; -&gt; (PhoneWindow.DecorView implements RootViewSurfaceTaker)#willYouTakeTheSurface() &#123; mFeatureId==-1 &lt; 0: return PhoneWindow.mTakeSurfaceCallback; &#125; -&gt; ViewRootImpl#enableHardwareAcceleration() &#123; // HardwareRenderer.isAvailable() == true mAttachInfo.mHardwareRenderer = HardwareRenderer.createGlRenderer(2, translucent); mAttachInfo.mHardwareAccelerated = mAttachInfo.mHardwareAccelerationRequested = true; &#125; -&gt; HardwareRenderer#createGlRenderer() -&gt; Gl20Renderer#create(translucent) &#123; if(GLES20Canvas.isAvailable(): new Gl20Renderer(translucent); &#125; -&gt; Session#addToDisplay() --Binder通信--&gt; WindowManagerService#addWindow(session, client==W, seq==0, attrs, viewVisibility, displayId, outContentInsets, outInputChannel) &#123; type == TYPE_BASE_APPLICATION; (WindowToken token) 在 ActivityStack#startActivityLocked() -&gt; WMS#addAppToken() 中设置, 不为空. (AppWindowToken atoken) 同上, 不为空. win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); (WindowManagerPolicy mPolicy 就是 PhoneWindowManager).adjustWindowParamsLw(win.mAttrs); mPolicy.prepareAddWindowLw(win, attrs); outInputChannel != null: InputChannel.openInputChannelPair(name); win.setInputChannel(inputChannels[0]); inputChannels[1].transferTo(outInputChannel); mInputManager.registerInputChannel(win.mInputChannel, win.minputWindowHandle); win.attach(); mWindowMap.put(client.asBinder(), win); type == TYPE_BASE_APPLICATION: addWindowToListInOrderLocked(win, true); win.mWinAnimator.mEnterAnimationPending = true; if(displayContent.isDefaultDisplay) mPolicy.getContentInsetHintLw(attrs, outContentInsets); mInputMonitor.setUpdateInputWindowsNeededLw(); if(win.canReceiveKeys()) focusChanged = updateFocusedWindowLocked(); assignLayersLocked(displayContent.getWindowList()); &#125; -&gt; WindowState#ctor(service, Session s, IWindow c, WindowToken token, WindowState attachedWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, final DisplayContent displayContent) &#123; mSession = s; mWindowId = new IWindowId.Stub() &#123;&#125; (IWindow c).asBinder().linkToDeath(new DeathRecipient(), 0); type == TYPE_BASE_APPLICATION: mBaseLayer = mPolicy.windowTypeToLayerLw(a.type) * ... + ...; mSubLayer = 0; mWinAnimator = new WindowStateAnimator(this); mWinAnimator.mAlpha = a.alpha; &#125; -&gt; WindowState#attach() &#123; mSession.windowAddedLocked(); &#125; -&gt; Session#windowAddedLocked() &#123; mSurfaceSession = new SurfaceSession(); (WMS mService).mSessions.add(this); mNumWindow++; &#125; -&gt; Activity#makeVisible() &#123; mWindowAdded == true: pass mDecor.setVisibility(View.VISIBLE); &#125; -&gt; PhoneWindow.DecorView#setVisibility(View.VISIBLE) -&gt; (父类View#)setVisibility(View.VISIBLE) -&gt; (父类View#)setFlags(flags==View.VISIBLE, mask==VISIBILITY_MASK) &#123; (changed &amp; VISIBILITY_MASK) != 0: mPrivateFlags |= PFLAG_DRAWN; invalidate(true); needGlobalAttributesUpdate(true); &#125; -&gt; (父类View#)invalidate(true) &#123; HardwareRenderer.RENDER_DIRTY_REGIONS == true: (p==mParent 这里是 ViewRootImpl).invalidateChild(this, r); &#125; -&gt; ViewRootImpl#invalidateChild(child==PhoneWindow.DecorView, dirty==r) -&gt; ViewRootImpl#invalidateChildInParent(null, dirty==r) &#123; mWillDrawSoon 初始化为false: scheduleTraversals(); &#125; -&gt; ViewRootImpl#scheduleTraversals() &#123; mTraversalScheduled = true; mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);// ViewRootImpl#doTraversal() scheduleConsumeBatchedInput(); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266ViewRootImpl#mChoreographer 是 ThreadLocal 的, 依附在 ViewRootImpl 所在的 Looper 上.USE_VSYNC 时用(FrameDisplayEventReceiver mDisplayEventReceiver).scheduleVsync() --VSYNC--&gt; onVsync() --Choreographer#mHandler--&gt; doFrame() -&gt; 从 CALLBACK_INPUT, CALLBACK_ANIMATION, CALLBACK_TRAVERSAL 队列取回调执行.ViewRootImpl#doTraversal() -&gt; ViewRootImpl#performTraversals() &#123; mIsInTraversal = true; mWillDrawSoon = true; mFirst == ture: mFullRedrawNeeded = true; mLayoutRequested = true; attachInfo.mSurface = mSurface; (host==mView DecorView).dispatchAttachedToWindow(attachInfo, 0); ... host.fitSystemWindows(); mLayoutRequest == true &amp;&amp; !mStopped: ensureTouchModeLocally(); measureHierarchy(host, lp, res, disiredWindowWidth, desiredWindowHeight); hadSurface = mSurface.isValid(); // == false, 下面relayoutWindow填充 mFirst == true: relayoutWindow(params, viewVisibility, insetsPending); !mStopped: performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); didLayout: performLayout(lp, desiredWindowWidth, desiredWindowHeight); mFirst == true: mView.requestFocus(View.FOCUS_FORWARD); !hadSurface &amp;&amp; mSurface.isValid(): &#123; newSurface = true; mFullRedrawNeeded = true; &#125; // If we are creating a new surface, then we need to // completely redraw it. Also, when we get to the // point of drawing it we will hold off and schedule // a new traversal instead. mWillDrawSoon = false; ... scheduleTraversals(); // 第二遍时会调 performDraw() mIsInTraversal = false; &#125; -&gt; (DecorView 父类 ViewGroup)#dispatchAttachedToWindow(attachInfo, visibility==0) &#123; for child: child.dispatchAttachedToWindow(info, ...); // (View child).mAttachInfo = info // 动态添加的view也可以在 addView() -&gt; addViewInner() 时设置 mAttachInfo &#125; -&gt; (DecorView 父类 ViewGroup)#fitSystemWindows() &#123; done = (super==View).fitSystemWindows(); // View#computeFitSystemWindows() if(!done): for child: done = child.fitSystemWindows(); &#125; -&gt; (DecorView 父类 View)#fitSystemWindows() -&gt; DecorView#internalSetPadding() -&gt; View#internalSetPadding() &#123; if(changed): requestLayout(); &#125; -&gt; ViewRootImpl#measureHierarchy() -&gt; ViewRootImpl#performMeasure() &#123; (DecorView mView).measure(); &#125; -&gt; (DecorView 父类View)#measure() -&gt; DecorView#onMeasure() -&gt; MeasureSpec#makeMeasureSpec() -&gt; (父类FrameLayout)#onMeasure() &#123; for(getChildCount()) measureChildWithMargins(child, ...); setMeasuredDimension(resolveSizeAndState(), ...); &#125; -&gt; (父类View)#measureChildWIthMargins() &#123; child.measure(); &#125; --如果有child--&gt; (View或其子类)#measure() -&gt; (View或其子类)#onMeasure() -&gt; (View或其子类)#setMeasuredDimension() -&gt; ViewRootImpl#relayoutWindow() &#123; (IWindowSession mWindowSession).relayout(); &#125; --Binder通信--&gt; Session#relayout() -&gt; WindowManagerService#relayoutWindow() &#123; (WindowStateAnimator winAnimator).applyEnterAnimationLocked(); outSurface.copyFrom(winAnimator.createSurfaceLocked()); ... performLayoutAndPlaceSurfacesLocked(); &#125; -&gt; WindowStateAnimator#createSurfaceLocked() &#123; (WMS mService).makeWindowFreezingScreenIfNeededLocked(mWin); mSurfaceControl = new SurfaceControl(mSession.mSurfaceSession, attrs.getTitle(), w, h, format, flags); SurfaceControl.openTransaction(); mSurfaceControl.setPosition(mSurfaceX, mSurfaceY); mSurfaceLayer = mAnimLayer; mSurfaceControl.setLayerStack(mLayerStack); mSurfaceControl.setLayer(mAnimLayer); mSurfaceControl.setAlpha(0); &#125; -&gt; WMS#performLayoutAndPlaceSurfacesLocked() &#123; loopCount = 6; do &#123; mTraversalScheduled = false; performLayoutAndPlaceSurfacesLockedLoop(); ... loopCount--; &#125; while(mTraversalScheduled &amp;&amp; loopCount &gt; 0); &#125; -&gt; WMS#performLayoutAndPlaceSurfacesLockedLoop() -&gt; WMS#performLayoutAndPlaceSurfacesLockedInner() &#123; ... performLayoutLockedInner(displayContent, repeats == 1, false); ... scheduleAnimationLocked(); &#125; -&gt; WMS#performLayoutLockedInner() &#123; (mPolicy 就是 PhoneWindowManager).beginLayoutLw(isDefaultDisplay, dw, dh, mRotation); // 计算 mNavigationBar.computeFrameLw() 和 mStatusBar.computeFrameLw() for WindowState win: !gone &amp;&amp; !win.mLayoutAttached: win.preLayout(); mPolicy.layoutWindowLw(win, win.mAttrs, null); &#125; -&gt; PhoneWindowManager#layoutWindowLw(WindowState win, win.mAttrs, attached==null) &#123; win.computeFrameLw(pf, df, of, cf, vf); // 设置 mContainingFrame, mDisplayFrame, mParentFrame, mOverScanFrame, // mContentFrame, mVisibleFrame, mFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mCompatFrame 等 &#125; -&gt; WMS#scheduleAnimationLocked() &#123; mAnimationScheduled = true; mChoreographer.postCallback(CALLBACK_ANIMATION, mAnimator.mAnimationRunnable, null;) &#125; -&gt; ViewRootImpl#performDraw() &#123; draw(fullRedrawNeeded); 如果有mSurfaceHolder,调SurfaceHolder.Callback; &#125; -&gt; ViewRootImpl#draw(fullRedrawNeeded) &#123; sFirstDrawComplete 初始化为false: for() mHandler.post(sFirstDrawHandlers.get(i)); !dirty.isEmpty(): attachInfo.mHardwareRenderer.isEnabled() 初始化为false, attachInfo.mHardwareRenderer.isRequested() 初始化== true: attachInfo.mHardwareRenderer.initializeIfNeeded(); mFullRedrawNeeded = true; scheduleTraversals(); // 下一遍 performTraversals() -&gt; performDraw() -&gt; draw() 时 attachInfo.mHardwareRenderer.draw(), // 就是 Gl20Renderer#draw() &#125; -&gt; (Gl20Renderer 父类HardwareRenderer)#initializeIfNeeded(width, height, surface) &#123; isRequested() == true, !isEnabled() == true: initialize(surface); setup(width, height); &#125; -&gt; (Gl20Renderer 父类GlRenderer)#initialize(surface) &#123; initializeEgl(); // sEgl = com.google.android.gles_jni.EGLImpl() mGl = createEglSurface(surface); mCanvas = createCanvas(); // GLES20Canvas setEnabled(true); &#125; -&gt; Gl20Renderer#createCanvas() &#123; mGlCanvas = new GLES20Canvas(mTranslucent); &#125; -&gt; GLES20Canvas#ctor(record==false, translucent) &#123; mRenderer = nCreateRenderer(); // C++: new OpenGLRenderer() setupFinalizer(); // new CanvasFinalizer(mRenderer) &#125; -&gt; (Gl20Renderer 父类GlRenderer)#draw(view, attachInfo, callbacks, dirty) &#123; dirty = beginFrame(canvas, dirty, surfaceState); // canvas == mCanvas DisplayList displayList = buildDisplayList(view, mCanvas); status = prepareFrame(dirty); saveCount = canvas.save(); callbacks.onHardwarePreDraw(canvas); displayList != null: status |= drawDisplayList(attachInfo, canvas, displayList, status); callbacks.onHardwarePostDraw(canvas); canvas.restoreToCount(saveCount); onPostDraw(); swapBuffers(status); attachInfo.mIgnoreDirtyState = false; &#125; -&gt; (Gl20Renderer 父类HardwareRenderer)#beginFrame() -&gt; nBeginFrame() --JNI--&gt; android_view_HardwareRenderer_beginFrame() &#123; EGLDisplay display = eglGetCurrentDisplay(); EGLSurface surface = eglGetCurrentSurface(EGL_DRAW); eglBeginFrame(display, surface); &#125; -&gt; (Gl20Renderer 父类Glrenderer)#buildDisplayList(view, canvas) &#123; view.getDisplayList(); &#125; -&gt; View#getDisplayList() -&gt; View#getDisplayList(mDisplayList, isLayer==false) &#123; if displayList!=null: // 非第一次 dispatchGetDisplayList(); // DecorView 父类 ViewGroup#dispatchGetDisplayList &#123; for child: child.getDisplayList(); &#125; else: // 第一次 !isLayer: mRecreateDisplayList = true; displayList = (Gl20Renderer mAttachInfo.mHardwareRenderer).createDisplayList(name); // new GLES20DisplayList invalidateParentCaches(); // mParent.mPrivateFlags |= PFLAG_INVALIDATED HardwareCanvas canvas = displayList.start(width, height); // GLES20RecordingCanvas layerType 初始化为 LAYER_TYPE_NONE: computeScroll(); canvas.translate(-mScrollX, -mScrollY); (View#)draw(canvas); displayList.end(); displayList.setCaching(caching); setDisplayListProperties(displayList); &#125; -&gt; GLES20DisplayList#start(width, height) &#123; mCanvas = GLES20RecordingCanvas.obtain(this); // GLES20RecordingCanvas mCanvas.start(); // &#123; mDisplayList.mBitmaps.clear(); mDisplayList.mChildDisplayLists.clear(); 都是ArrayList&#125; mCanvas.setViewport(width, height); mCanvas.onPreDraw(null); // --JNI--&gt; nPrepare() --C++--&gt; (OpenGlRenderer renderer)-&gt;prepareDirty() &#125; -&gt; GLES20RecordingCanvas#obtain(DisplayList) &#123; new GLES20RecordingCanvas(); // 父类 GLES20Canvas(true, true) &#123; nCreateDisplayListRenderer(); // C++:new DisplayListRenderer &#125; &#125; -&gt; (DecorView 父类View)#draw(canvas) &#123; // DecorView#draw() -&gt; FrameLayout#draw() -&gt; ViewGroup#draw() // light version onDraw(canvas); dispatchDraw(canvas); onDrawScrollBars(canvas); // full version canvas.saveLayer(); onDraw(canvas); dispatchDraw(canvas); canvas.drawRect(); onDrawScrollBars(canvas); &#125; -&gt; ViewGroup#dispatchDraw() &#123; for child: drawChild(canvas, child, drawingTime) -&gt; (View child).draw(canvas, this, drawingTime) &#125; -&gt; View#draw(canvas, parent==ViewGroup, drawingTime) &#123; useDisplayListProperties == true; hardwareAccelerated == true: // GLES20Canvas 父类HardwareCanvas 直接返回 caching = true; layerType == LAYER_TYPE_NONE: 初始化值 hasDisplayList = canHaveDisplayList(); // true useDisplayListProperties &amp;= hasDisplayList; // true useDisplayListProperties == true: displayList = getDisplayList(); // !!递归调自己 hasNoCache == true: (HardwareCanvas 子类 GLES20RecordingCanvas canvas).drawDisplayList(displayList, null, flags); &#125; -&gt; GLES20RecordingCanvas#drawRect() &#123; super.drawRect(); // (父类 GLES20Canvas)#drawRect() -&gt; nDrawRect() --JNI--&gt; (OpenGLRenderer renderer).drawRect() recordShaderBitmap(paint); // mDisplayList.mBitmaps.add() -&gt; GLES20DisplayList#end() &#123; (GLES20RecordingCanvas mCanvas).onPostDraw(); mFinalizer == null: mFinalizer = new DisplayListFinalizer(mCanvas.end(0)); mCanvas.recycle(); mCanvas = null; mValid = true; &#125; -&gt; GLES20RecordingCanvas#end(0) -&gt; (父类 GLES20Canvas)#getDisplayList(0) --JNI--&gt; (DisplayListRenderer renderer).getDisplayList(DisplayList displayList==NULL) &#123; C++: return new DisplayList(*this); &#125; -&gt; GLES20RecordingCanvas#recycle() &#123; mDisplayList = null; resetDisplayListRenderer(); // (父类 GLES20Canvas)#resetDisplayListRenderer() -&gt; nResetDisplayListRenderer sPool.release(this); // 放入缓存池, 方便下次重用 &#125; -&gt; (Gl20Renderer 父类GlRenderer)#prepareFrame(dirty) -&gt; Gl20Renderer#onPreDraw(dirty) -&gt; (GLES20Canvas mGlCanvas)#onPreDraw(dirty) --JNI--&gt; nPrepareDirty() -&gt; (OpenGLRenderer renderer).prepareDirty() &#123; setupFrameState(); if(mSnapshot-&gt;fbo == 0) syncState(); updateLayers(); else startFrame(); &#125; -&gt; OpenGlRenderer::setupFrameState() &#123; mCaches.clearGarbage(); mSnapshot = new Snapshot(); mSnapshot-&gt;fbo = getTargetFbo(); &#125; -&gt; GLES20Canvas#drawDisplayList() --JNI--&gt; nDrawDisplayList() --C++--&gt; (OpenGLRenderer renderer)::drawDisplayList() &#123; if(CC_UNLIKELY(mCaches.drawDeferDisabled)): status = startFrame(); displayList.replay(replayStruct, 0); return status | replayStruct.mDrawGlStatus; displayList.defer(deferStruct, 0); flushLayers(); status = startFrame(); return status | deferredList.flush(*this, dirty); &#125; -&gt; (Gl20Renderer 父类Glrenderer)#swapBuffers(status) &#123; if(status &amp; DisplayList.STATUS_DREW) (EGL10 sEgl).eglSwapBuffers(sEglDisplay, mEglSurface); checkEglErrors(); &#125; -&gt; (EGL10 sEgl)#eglSwapBuffers() --JNI--&gt; jni_eglSwapBuffers() --C++--&gt; eglSwapBuffers(dpy, sur)","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"Android 输入系统 源码分析","date":"2013-11-04T08:45:00.000Z","path":"android/input-system/","text":"版本 android-4.3_r2.2涉及到的文件 frameworks/base/services/input/InputDispatcher.cpp InputDispatcher InputDispatcherThread frameworks/base/services/input/InputReader.cpp InputReader InputReaderThread frameworks/base/services/input/EventHub.cpp frameworks/base/services/java/com/android/server/input/InputManagerService.java frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp frameworks/base/core/jni/android_view_InputChannel.cpp NativeInputChannel frameworks/base/services/input/InputManager.cpp frameworks/native/libs/utils/Threads.cpp /frameworks/base/include/androidfw/InputTransport.h .cpp InputPublisher InputChannel 初始化( SystemServer.java: ServerThread#run() )1234567891011NIM: NativeInputManagerInputManagerService#ctor()--JNI--&gt; nativeInit()--C++--&gt; NativeInputManager::ctor()-&gt; InputManager::ctor(new eventHub(), NIM, NIM) &#123;mDispatcher=InputDispatcher::ctor(NIM), mReader=InputReader::ctor(eventHub==new eventHub in NIM, NIM, mDispatcher), InputReader::mQueuedListener=QueuedInputListener::ctor(mDispatcher)) &#125;-&gt; InputManager::initialize() &#123; InputReaderThread::ctor(mReader), InputDispatcherThread::ctor() &#125;InputManagerService#setWindowManagerCallbacks(wm.getInputMonitor()) &#123; mWindowManagerCallbacks == InputMonitor#ctor() &#125; 启动( SystemServer.java: ServerThread#run() )123456789101112131415161718192021InputManagerService#start()--JNI--&gt; nativeStart()--C++--&gt; InputManager::start() &#123; mDispatcherThread-&gt;run(), mReaderThread-&gt;run() &#125;InputDispatcherThread::run() [重载 Thread::run] &#123; androidCreateRawThreadEtc() -&gt; pthread_create() --新线程--&gt; Thread::_threadLoop() --无限循环--&gt; InputDispatcherThread::threadLoop() -&gt; Dispatcher::dispatchOnce() &#125;InputReaderThread::run() [重载 Thread::run] --新线程--&gt; ... --无限循环--&gt; InputReaderThread::threadLoop() -&gt; mReader::loopOnce() &#123; mEventHub::getEvents(timeout, eventBuffer), processEventsLocked(eventBuffer), 更新inputDevices列表, mQueuedListener::flush() &#125; -&gt; EventHub::getEvents() &#123; (mNeedToScanDevices 初始化为 true) scanDevicesLocked(), 无限循环: 处理 ReopenDevice/ScanDevice/pendingEvent, epoll_wait(device_fds) 获取 pendingEvent &#125;EventHub::scanDevicesLocked()-&gt; EventHub::scanDirLocked(&quot;/dev/input&quot;) &#123; foreach devFile: openDeviceLocked(devname) &#125;-&gt; EventHub::openDeviceLocked() &#123; LoadConfigurationLocked(), epoll_ctl(CTL_ADD), addDeviceLocked() &#125;-&gt; EventHub::addDeviceLocked() &#123; 加到 mDevices &#125; 建立连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061如果没有任何连接, InputDispatcher会扔掉接收到的按键.ViewRootImpl#setView() &#123; mInputChannel=InputChannel#ctor, mWindowSession.addToDisplay(..., mInputChannel), mInputEventReceiver = WindowInputEventReceiver#ctor((mInputChannel==transfer过来的客户端channel), Looper.myLooper()) &#125;mWindowSession.addToDisplay()--Binder--&gt; Session#addToDisplay(..., outInputChannel==mInputChannel)-&gt; WindowManagerService#addWindow(..., outInputChannel) &#123; inputChannels=InputChannel#openInputChannelPair(name), (WindowState win).setInputChannel(inputChannels[0]), inputChannels[1].transferTo(outInputChannel), 结果是 ViewRootImpl#mInputChannel 赋值为 socketpair() 客户端 (InputManagerService mInputManager).registerInputChannel(win.mInputChannel==inputChannels[0], ...), 结果是 InputDispatcher 中一个 Connection::inputChannel 赋值为 socketpair() 服务器端 &#125;WindowInputEventReceiver#ctor()-&gt; InputEventReceiver#ctor()--JNI--&gt; InputEventReceiver::nativeInit() &#123; receiver=NativeInputEventReceiver::ctor(), receiver-&gt;initialize() &#125;-&gt; receiver-&gt;initialize()-&gt; setFdEvents() &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(mInputConsumer.getChannel()-&gt;getFd()) 客户端, ViewRootImpl Looper &#125;InputChannel#openInputChannelPair()--JNI--&gt; nativeOpenInputChannelPair()--C++--&gt; InputChannel::openInputChannelPair([0]==serverChannel, [1]==clientChannel) &#123; fd[2]=socketpair(), serverChannel.mFd=fd[0], clientChannel.mFd=fd[1] &#125;InputChannel#transferTo()--JNI--&gt; nativeTransferTo() &#123; outInputChannel=inputChannels[1], inputChannels[1]==null &#125;InputManagerService#registerInputChannel(inputChannel)--JNI--&gt; nativeRegisterInputChannel(inputChannel)--C++--&gt; (NativeInputManager im)-&gt;registerInputChannel(env, inputChannel, ...)-&gt; InputManager::-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, ...)-&gt; InputDispatcher::registerInputChannel() &#123; Connection::ctor(inputChannel, ...), mLooper-&gt;addFd(inputChannel-&gt;getFd(), ...) &#125;Looper::addFd() &#123; epoll_ctl(ADD/MOD), 加入到 mRequests 队列 &#125;接收event------------------------ViewRootImpl#requestLayout() / invalidate() / setLayoutParams() 等-&gt; ViewRootImpl#scheduleTraversals()-&gt; ViewRootImpl#scheduleConsumeBatchedInput()--Looper机制--&gt; (ConsumeBatchedinputRunnable mConsumedBatchedInputRunnable)#run()-&gt; ViewRootImpl#doConsumeBatchedInput()-&gt; (WindowInputEventReceiver mInputEventReceiver).consumeBatchedInputEvents()-&gt; InputEventReceiver#consumeBatchedInputEvents()--JNI--&gt; nativeConsumeBatchedInputEvents(receiver)--C++--&gt; (NativeInputEventReceiver receiver)::consumeEvents() &#123; 无限循环: [ (InputConsumer mInputConsumer==WRAPS(inputChannel == InputEventReceiver 构造时传入)).consume(), (JNI调java) InputEventReceiver#dispatchInputEvent()] &#125;InputEventReceiver#dispatchInputEvent() --重载--&gt; WindowInputEventReceiver::onInputEvent(event) -&gt; ViewRootImpl#enqueueInputEvent()InputConsumer::consume()-&gt; mChannel-&gt;receiveMessage(), 是 socketpair() 客户端 &#123; UNIX Socket ::recv(mFd) &#125; InputReader处理12345678910111213141516InputReaderThread::processEventsLocked(deviceId, rawEvents, count)-&gt; --::processEventsForDeviceLocked(deviceId, rawEvent, batchSize) [或 add/remove)DeviceLocked / handleConfigurationChangedLocked]-&gt; mDevices中取 (InputDevice device)::process(rawEvents, count) &#123; for rawEvents: 命令扔掉 or &#123; for mMappers: InputMapper::process(rawEvent) &#125; &#125; mMappers 在 InputReader::createDeviceLocked() 中添加, 包括 (Switch/Vibrator/Keyboard/Cursor/MultiTouch/SingleTouch/Joystick)InputMapper-&gt; InputMapper子类::process(rawEvent), 以Keyboard为例 &#123; mReader-&gt;mQueuedListener::notifyKey(args) &#125;-&gt; QueuedInputListener::notifyKey(args) &#123; (Vector&lt;NotifyArgs*&gt; mArgsQueue).push(new NotifyKeyArgs(*args)) &#125;(QueuedInputListener mQueuedListener)::flush()-&gt; NotifyArgs::notify(mInnerListener==InputDispatcher)-&gt; InputDispatcher::notifyKey(NotifyKeyArgs) &#123; mPolicy-&gt;interceptKeyBeforeQueueing(), enqueueInboundEventLocked(newEntry) &#125;InputDispatcher::enqueueInboundEventLocked(entry) &#123; mInboundQueue.enqueueAtTail(entry) &#125;InputReaderThread和InputDispatcherThread两线程对 inBoundQueue 的访问是通过 InputDispatcher::mLock 锁来保护的. InputDispatcher处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263InputDispatcher::dispatchOnce() &#123; dispatchOnceInnerLocked() 最终目的 UNIX Socket send 给注册的 inputChannel, mLooper-&gt;pollOnce() 最终目的 epoll_wait(inputChannelFd) 确认应用返回的已处理消息 &#125;dispatchOnceInnerLocked() [或 runCommandsLockedInterruptible()]------------------------ &#123; mInboundQueue.dequeueAtHead() , 以键盘 TYPE_KEY 为例 dispatchKeyLocked() &#125;InputDispatcher::dispatchKeyLocked(currentTime, entry, dopReason, nextWakeupTime) &#123; (policy==NIM) intercept key 转为 CommandEntry, 或 扔掉, 或 findFocusedWindowTargetsLocked(), dispatchEventLocked(currentTime, entry, inputTargets) &#125;-&gt; dispatchEventLocked() &#123; foreach (InputDispatcher::Connection connection): prepareDispatchCycleLocked() &#125;-&gt; prepareDispatchCycleLocked()-&gt; enqueueDispatchEntriesLocked() &#123; enqueueDispatchEntryLocked(), 若之前为空则 startDispatchCycleLocked() &#125;-&gt; enqueueDispatchEntryLocked() &#123; connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry) &#125;(policy==NIM) intercept key-&gt; InputDispatcher::postCommandLocked()--重新以CommandEntry形式dispatch--&gt; InputDispatcher::runCommandsLockedInterruptible() &#123; (commandEntry-&gt;command函数指针==doInterceptKeyBeforeDispatchingLockedInterruptible)(commandEntry) &#125;-&gt; (mPolicy==NIM)-&gt;interceptKeyBeforeDispatching()--JNI回调java--&gt; InputManagerService#interceptKeyBeforeDispatching()--JAVA--&gt; (mWindowManagerCallbacks==InputMonitor).interceptKeyBeforeDispatching()-&gt; (WindowManagerService mService).(WindowManagerPolicy mPolicy==Binder通信的PhoneWindowManager).interceptKeyBeforeDispatching()--Binder通信--&gt; PhoneWindowManager#interceptKeyBeforeDispatching() &#123; HOME/MENU/SEARCH 等全局键处理 &#125;InputDispatcher::startDispatchCycleLocked(currentTime, connection) &#123; 以键盘 TYPE_KEY 为例 connection-&gt;( InputPublisher inputPublisher ==WRAPS(mChannel)== connection 建立时的 inputChannel == NativeInputChannel 建立时的 inputChannel )-&gt;publishKeyEvent(), 如果成功则 connection-&gt;outboundQueue.dequeue(dispatchEntry), connection-&gt;waitQueue.enqueueAtTail(dispatchEntry) &#125;-&gt; InputPublisher::publishKeyEvent()-&gt; (InputChannel mChannel)::sendMessage(InputMessage::ctor()) &#123; UNIX Socket ::send(mFd, msg ...) &#125;InputDispatcher::Connection 类在 InputDispatcher.h 中. 所有的connection在 InputDispatcher::registerInputChannel() 中注册.mLooper-&gt;pollOnce()-------------------------&gt; Looper::pollInner() &#123; epoll_wait(inputChannelFd), foreach event: [pushResponse(events, mRequests[idx])], foreach in mMessageEnvelopes: messageEnvelope.handler-&gt;handleMessage(messageEnvelope.messge), foreach in mResponses: response.request.callback-&gt;handleEvent() &#125;-&gt; Looper::pushResponse() &#123; 添加到 mResponses 队列 &#125;-&gt; response.request.callback-&gt;handleEvent()-&gt; InputDispatcher::handleReceiveCallback() &#123; connection-&gt;inputPublisher.receiveFinishedSignal(), (InputDispatcher d)-&gt;finishDispatchCycleLocked() &#125;InputPublisher::receiveFinishedSignal()-&gt; mChannel-&gt;receiveMessage(), 是 socketpair() 服务器端InputDispatcher::finishDispatchCycleLocked()-&gt; InputDispatcher::onDispatchCycleFinishedLocked() &#123; 通知并准备下个 dispatch cycle &#125;--mCommandQueue队列--&gt; InputDispatcher::doDispatchCycleFinishedLockedInterruptible() &#123; connection-&gt;waitQueue.dequeue(dispatchEntry), startDispatchCycleLocked() &#125;Looper机制----------------------------------ActivityThread#main()-&gt; Looper#loop() &#123; 无限循环: 处理 (MessageQueue queue).next() &#125;-&gt; MessageQueue#next()--JNI--&gt; nativePollOnce()--C++--&gt; NativeMessageQueue::pollOnce()-&gt; Looper::pollOnce()","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"用Octopress在GitHub上搭建博客","date":"2013-09-01T05:23:00.000Z","path":"博客搭建/octopress-setup/","text":"目录 {:toc} 备料注册 GitHub 账户并创建一个空仓库 (假定注册名为 yourname, 注册邮箱 yourname@gmail.com, 下同) 创建空仓库 yourname.github.io 下载并配置 Git下载 Linux 使用系统包管理安装git Windows MsysGit vim着色：MsysGit上的vim着色文件不全, 可从完整vim73的syntax目录拷过来, 如 /usr/share/vim/vim73/syntax 配置设置 LANG 环境变量(可以不设LC_ALL; 可以不是zh_CN, 后缀是UTF-8即可;) 12345678910111213141516171819# locale和中文显示touch ~/.bashrcecho 'export LANG=\"en_US.UTF-8\"' &gt;&gt; ~/.bashrctouch ~/.inputrcecho 'set meta-flag on' &gt;&gt; ~/.inputrcecho 'set convert-meta off' &gt;&gt; ~/.inputrcecho 'set input-meta on' &gt;&gt; ~/.inputrcecho 'set output-meta on' &gt;&gt; ~/.inputrctouch ~/.vimrcecho 'set fileencodings=utf-8' &gt;&gt; ~/.vimrc# git optionsgit config --global user.name \"yourname\"git config --global user.email \"yourname@gmail.com\"git config core.autocrlf falsegit config credential.helper 'cache --timeout=3600' # Keep your password cached in memorygit config github.user \"yourname\"# ssh keyssh-keygen -t rsa -C \"yourname@gmail.com\"cat ~/.ssh/id_rsa.pub # 将内容复制到 https://github.com/settings/ssh 上 下载并配置 Ruby(1.9.3)下载 Windows 7zip包解压(假设到 D:\\ruby1.9.3), 添加到系统PATH 下载并配置 DevKit(wiki) 1.9.3 配对 DevKit-tdm, 解压(假设到 D:\\ruby1.9.3-DevKit), 添加到系统PATH 1234567cd /D/ruby1.9.3-DevKitruby dk.rb initruby dk.rb review # 确认ruby位置正确ruby dk.rb install# 验证DevKitgem install json --platform=ruby # 能看到 build nativeruby -rubygems -e \"require 'json'; puts JSON.load('[42]').inspect\" # 确认json gem安装成功 Linux 使用 RVM(Ruby版本管理) 1234567# install RVM stable with ruby in user's $HOME\\curl -L http://get.rvm.io | bash -s stable --ruby # 反斜杠是防止使用到 ~/.curlrc 定义的 alias# rvm安装完毕# rvm list knownrvm install 1.9.3rvm use 1.9.3 --default# ruby -v 配置1234# gem更新源gem sources --remove http://rubygems.org/ # 要包含最后的斜杠gem sources -a http://ruby.taobao.org/gem sources -l # 验证源只有 ruby.taobao.org 安装Octopress12345git clone git://github.com/imathis/octopress.git mygithubiocd mygithubiogem install bundler # 不是 bundlebundle install # 下载安装依赖项目(bundle是ruby的依赖管理工具)rake install # 编译octopress项目(Rake to Ruby == Make to C) 1rake setup_github_pages hellip; 不是内部命令错误 1 Rakefile文件 My Octopress Page is coming soon &amp;hellip; 在 &amp;hellip; 前加 ^ (Windows cmd转义) setup_github_pages目标主要做了2件事: 将原来git upstream的 origin 改到 octopress 将你在 GitHub 上的博客地址(如 yourname.github.io) 作为 origin. 验证: git remote -v 1234# rake new_post['hello octopress'] # 创建新markdown博文rake generate # 确保 `.gitignore` 包含忽略 _deploy 目录# rake preview # 可通过本机4000端口预览# rake deploy # push 到 GitHub 博客项目的 master 分支 错误排查找不到python21312cd D:\\Python27mklink /H python2.exe python.exe 基本使用和配置使用rake new_post[&#39;new-post-today&#39;] 生成新博文rake new_page[&#39;new-page-in-here&#39;] 生成新页面(不属于博文系列)配置2_config.yml123456# 博客链接格式permalink: /blog/:year/:month-:day-:title.html# 使用kramdownmarkdown: kramdown# SEOdescription: yourname的技术博客 自动生成目录6使用kramdown(下面配置), 写博客时加入以下两行即可自动生成目录:12* list element with functor item&#123;:toc&#125; 目录样式touch sass/custom/_styles.scss, 添加 12345678910111213141516#markdown-toc:before &#123; content: \"TOC\"; font-weight: bold;&#125;ul#markdown-toc &#123; list-style: none; display: inline-block;// float: left; background-color: LightGray; margin-right:2em; border-radius: 1em; box-shadow: 0px 1px 4px; -moz-box-sizing: border-box; padding: 10px 10px 10px 20px;&#125; 侧栏about me_config.yml 的 default_asides 里添加 custom/asides/about.htmltouch source/_includes/custom/asides/about.html, 添加内容1234567&lt;section&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;p&gt;一句话介绍&lt;/p&gt; &lt;p&gt;微博: &lt;a href=\"http://weibo.com/yourname\"&gt;@yourweiboname&lt;/a&gt;&lt;br/&gt; &lt;p&gt;豆瓣: &lt;a href=\"http://douban.com/yourname\"&gt;@yourdoubanname&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;&lt;/section&gt; 分类标签(支持中文)/categories5categories 多个以逗号分隔 中文支持: 确认 plugins/category_generator.rb 中 write_category_indexes 和 category_link 函数包含 to_url 调用 (url 不区分大小写, 不用再调 downcase)12345# 109行附近self.write_category_index(File.join(dir, category.to_url), category)# 176行附近\"&lt;a class='category' href='/#&#123;dir&#125;/#&#123;category.to_url&#125;/'&gt;#&#123;category&#125;&lt;/a&gt;\" touch plugins/category_list_tag.rb, 添加内容123456789101112131415module Jekyll class CategoryListTag &lt; Liquid::Tag def render(context) html = \"\" categories = context.registers[:site].categories.keys categories.sort.each do |category| posts_in_category = context.registers[:site].categories[category].size html &lt;&lt; \"&lt;li class='category'&gt;&lt;a href='/blog/categories/#&#123;category.to_url&#125;/'&gt;#&#123;category&#125; (#&#123;posts_in_category&#125;)&lt;/a&gt;&lt;/li&gt;\\n\" end html end endendLiquid::Template.register_tag('category_list', Jekyll::CategoryListTag) touch source/_includes/asides/category_list.html, 添加内容123456&lt;section&gt; &lt;h1&gt;Categories&lt;/h1&gt; &lt;ul id=\"categories\"&gt; &#123;% category_list %&#125; &lt;/ul&gt;&lt;/section&gt; _config.yml 中 default_asides 添加 asides/category_list.htmlJekyll+lunr.js 即时搜索7 下载 jekyll_lunr_js_search.rb 放到 plugins 目录. 可按 8 中提示修改一个小bug. 下载 jquery.lunr.search.js 放到 source/javascripts 目录 jQuery 已在 Octopress 中内置: source/javascripts/libs/jquery.min.js 下载 以下几个 javascript 依赖, 放到 source/javascripts 目录 lunr.min.js mustache.js date.format.js URI.min.js gem install nokogiri json 安装依赖, gem list 查看 nokogiri 版本(假设为 1.6.0) 修改 Gemfile, 标明依赖 gem &#39;nokogiri&#39;, &#39;~&gt; 1.6.0&#39; rake new_page[&#39;search&#39;], 编辑 search页(source/search/index.markdown): 屏蔽页面被索引有两种方式 每个 markdown页 的 YAML配置头 加 exclude_from_search: true _config.yml 统一添加(即使没有也添加, 防止索引运行出错) 12lunr_search: excludes: [rss.xml, atom.xml] 首页添加链接到 search页面 重新 rake generate Header about页面 1rake new_page['about'] # 生成 source/about/index.markdown 头部导航菜单 /source/_includes/custom/navigation.html 加入 about页面 链接. 字体 source/_includes/custom/head.html 全部注释掉, 不装载 Google Webfonts(此字体没有包含中文, 粗体中文显示不出) sass/custom/_fonts.scss 添加(最佳 Web 中文默认字体) 123$heading-font-family: arial, sans-serif;$header-title-font-family: arial, sans-serif;$header-subtitle-font-family: arial, sans-serif; 社交功能分享功能JiaThis3_config.yml 加入变量 12# JiaThisjiathis: true source/_includes/post/sharing.html 尾部 &lt;/div&gt; 之前添加 123&#123;% if site.jiathis %&#125; &#123;% include post/jiathis.html %&#125;&#123;% endif %&#125; touch source/_includes/post/jiathis.html, 将从 JiaThis 获得的代码放入其中 评论功能多说4_config.yml 加入变量 123# DuoShuo commentsduoshuo_comments: trueduoshuo_short_name: yourname source/_layouts/post.html 中 disqus 代码下添加 (单独页面也加评论的话 source/_layouts/page.html 中也放相同代码) 123456&#123;% if site.duoshuo_short_name and site.duoshuo_comments == true and page.comments == true %&#125; &lt;section&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;div id=\"Comments\" aria-live=\"polite\"&gt;&#123;% include post/duoshuo-thread.html %&#125;&lt;/div&gt; &lt;/section&gt;&#123;% endif %&#125; 创建 source/_includes/post/duoshuo-thread.html, 将从多说获得的代码放入其中 统计功能站长统计source/_includes/custom/footer.html 中加入注册后给出的统计代码. 换主题bootstrap-theme , 或者其他的 123git clone http://github.com/bkutil/bootstrap-theme.git .themes/bootstrap-themerake install['bootstrap-theme'] # 注意: 换主题后所有非custom目录下的内容都会被覆盖掉！！rake generate i18nI forked from hendricius/jekyll-i18n and adapted to octopress(in octopress-i18n). However, AFAIK there’s no i18n capable themes right now. You have to create your own theme branch and adapt to i18n. html中写 1&#123;% i18nvar %&#125; , source/_locales/zh_CN.yml 中定义对应变量 i18nvar: 中文名称 更新1234git pull octopress master # 自动或手动mergebundle installrake update_sourcerake update_style 使用 travis-ci 自动编译发布 登录Travis-CI, 注册授权, 右上角 Accounts, 对应项目repo 置为 ON 生成 https 访问 github 所需的 token. 可用9中的界面方法, 或10中的curl直接获取 gem install travis; travis encrypt GH_TOKEN=&lt;token&gt; 生成加密的token 修改 .travis.yml, 几点注意: 调用 rake 命令时前面要加 bundle exec, 防止 rake 命令版本冲突 Travis 默认使用 Gemfile.lock 中的信息, 但此文件中包含平台相关的build信息, 会导致nokogiri编译问题11. 所以最好是将 Gemfile 拷贝出一份独立的 Gemfile.travis 供 Travis 使用. Gemfile.travis 中的 source 此时也可改用通用的 rubygems Travis上构建时如果出现 Liquid Exception: Gist replied with 301 错误提示, 是Octopress的一个bug, 则需要更新一下Octopress12 123456789101112131415161718192021branches: only: - sourcelanguage: rubyrvm: - 1.9.3gemfile: - Gemfile.travisbefore_script: - git config --global user.name \"yourname\" - git config --global user.email \"yourname@gmail.com\" - export REPO_URL=\"https://$GH_TOKEN@github.com/$GH_REPO.git\" - bundle exec rake setup_github_pages[$REPO_URL]script: - bundle exec rake generateafter_script: - bundle exec rake deployenv: global: - GH_REPO=\"your_github_name/your_github_name.github.io\" - secure: \"&lt;your-travis-encrypted-token&gt;\" 修改 Rakefile 隐藏token 12345- puts \"Added remote #&#123;repo_url&#125; as origin\"+ puts \"Added remote as origin\" # don't put repo_url in travis-ci as it may contains token- system \"git push origin #&#123;deploy_branch&#125; --force\"+ system \"git push origin #&#123;deploy_branch&#125; --force --quiet\" # hide github token 支持https提交 12345- puts \"(For example, 'git@github.com:yourname/yourname.github.com)\"+ puts \"(For example, 'git@github.com:yourname/yourname.github.com' or 'https://github.com/yourname/yourname.github.com')\"- user = repo_url.match(/:([^\\/]+)/)[1]+ user = repo_url.match(/[\\/:]([^\\/]+)\\/[^\\/]+$/)[1] 跳过不需要触发travis的commit 12345- message = \"Site updated at #&#123;Time.now.utc&#125;\"+ message = \"Site updated at #&#123;Time.now.utc&#125;\\n\\n[ci skip]\"- system \"git commit -m \\\"Octopress init\\\"\"+ system \"git commit -m \\\"Octopress init\\n\\n[ci skip]\\\"\" README.markdown 加入 build 状态图标 1[![Build Status](https://travis-ci.org/yourname/yourname.github.io.png?branch=source)](https://travis-ci.org/yourname/yourname.github.io) 1.Octopress 笔记 ↩2.我的Octopress配置 ↩3.在 Windows7 下从头开始安装部署 Octopress ↩4.为 Octopress 添加多说评论系统 ↩5.讓Octopress有中文分類及側邊列 ↩6.Table of Contents in Octopress ↩7.Jekyll+lunr.js ↩8.使用Jekyll-Bootstrap搭建博客时出现的问题 ↩9.打造Octopress博客在线写作平台 ↩10.Octopress+Prose+Github+Travis CI = Coders’ Blog ↩11.travis-ci-nokogiri-LoadError ↩12.octopress-gist-replied-with-301 ↩13.Probmes using syntax highlighting with pygments on windows ↩","tags":[],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/categories/博客搭建/"}]}]}