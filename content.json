{"pages":[{"title":"About","date":"2019-05-02T14:43:32.204Z","path":"about/index.html","text":""},{"title":"Categories","date":"2019-05-02T14:43:32.211Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-05-02T14:43:32.224Z","path":"tags/index.html","text":""}],"posts":[{"title":"Android 输入系统 源码分析","date":"2013-11-04T08:45:00.000Z","path":"android/input-system/","text":"版本 android-4.3_r2.2涉及到的文件 frameworks/base/services/input/InputDispatcher.cpp InputDispatcher InputDispatcherThread frameworks/base/services/input/InputReader.cpp InputReader InputReaderThread frameworks/base/services/input/EventHub.cpp frameworks/base/services/java/com/android/server/input/InputManagerService.java frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp frameworks/base/core/jni/android_view_InputChannel.cpp NativeInputChannel frameworks/base/services/input/InputManager.cpp frameworks/native/libs/utils/Threads.cpp /frameworks/base/include/androidfw/InputTransport.h .cpp InputPublisher InputChannel 初始化( SystemServer.java: ServerThread#run() )1234567891011NIM: NativeInputManagerInputManagerService#ctor()--JNI--&gt; nativeInit()--C++--&gt; NativeInputManager::ctor()-&gt; InputManager::ctor(new eventHub(), NIM, NIM) &#123;mDispatcher=InputDispatcher::ctor(NIM), mReader=InputReader::ctor(eventHub==new eventHub in NIM, NIM, mDispatcher), InputReader::mQueuedListener=QueuedInputListener::ctor(mDispatcher)) &#125;-&gt; InputManager::initialize() &#123; InputReaderThread::ctor(mReader), InputDispatcherThread::ctor() &#125;InputManagerService#setWindowManagerCallbacks(wm.getInputMonitor()) &#123; mWindowManagerCallbacks == InputMonitor#ctor() &#125; 启动( SystemServer.java: ServerThread#run() )123456789101112131415161718192021InputManagerService#start()--JNI--&gt; nativeStart()--C++--&gt; InputManager::start() &#123; mDispatcherThread-&gt;run(), mReaderThread-&gt;run() &#125;InputDispatcherThread::run() [重载 Thread::run] &#123; androidCreateRawThreadEtc() -&gt; pthread_create() --新线程--&gt; Thread::_threadLoop() --无限循环--&gt; InputDispatcherThread::threadLoop() -&gt; Dispatcher::dispatchOnce() &#125;InputReaderThread::run() [重载 Thread::run] --新线程--&gt; ... --无限循环--&gt; InputReaderThread::threadLoop() -&gt; mReader::loopOnce() &#123; mEventHub::getEvents(timeout, eventBuffer), processEventsLocked(eventBuffer), 更新inputDevices列表, mQueuedListener::flush() &#125; -&gt; EventHub::getEvents() &#123; (mNeedToScanDevices 初始化为 true) scanDevicesLocked(), 无限循环: 处理 ReopenDevice/ScanDevice/pendingEvent, epoll_wait(device_fds) 获取 pendingEvent &#125;EventHub::scanDevicesLocked()-&gt; EventHub::scanDirLocked(&quot;/dev/input&quot;) &#123; foreach devFile: openDeviceLocked(devname) &#125;-&gt; EventHub::openDeviceLocked() &#123; LoadConfigurationLocked(), epoll_ctl(CTL_ADD), addDeviceLocked() &#125;-&gt; EventHub::addDeviceLocked() &#123; 加到 mDevices &#125; 建立连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061如果没有任何连接, InputDispatcher会扔掉接收到的按键.ViewRootImpl#setView() &#123; mInputChannel=InputChannel#ctor, mWindowSession.addToDisplay(..., mInputChannel), mInputEventReceiver = WindowInputEventReceiver#ctor((mInputChannel==transfer过来的客户端channel), Looper.myLooper()) &#125;mWindowSession.addToDisplay()--Binder--&gt; Session#addToDisplay(..., outInputChannel==mInputChannel)-&gt; WindowManagerService#addWindow(..., outInputChannel) &#123; inputChannels=InputChannel#openInputChannelPair(name), (WindowState win).setInputChannel(inputChannels[0]), inputChannels[1].transferTo(outInputChannel), 结果是 ViewRootImpl#mInputChannel 赋值为 socketpair() 客户端 (InputManagerService mInputManager).registerInputChannel(win.mInputChannel==inputChannels[0], ...), 结果是 InputDispatcher 中一个 Connection::inputChannel 赋值为 socketpair() 服务器端 &#125;WindowInputEventReceiver#ctor()-&gt; InputEventReceiver#ctor()--JNI--&gt; InputEventReceiver::nativeInit() &#123; receiver=NativeInputEventReceiver::ctor(), receiver-&gt;initialize() &#125;-&gt; receiver-&gt;initialize()-&gt; setFdEvents() &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(mInputConsumer.getChannel()-&gt;getFd()) 客户端, ViewRootImpl Looper &#125;InputChannel#openInputChannelPair()--JNI--&gt; nativeOpenInputChannelPair()--C++--&gt; InputChannel::openInputChannelPair([0]==serverChannel, [1]==clientChannel) &#123; fd[2]=socketpair(), serverChannel.mFd=fd[0], clientChannel.mFd=fd[1] &#125;InputChannel#transferTo()--JNI--&gt; nativeTransferTo() &#123; outInputChannel=inputChannels[1], inputChannels[1]==null &#125;InputManagerService#registerInputChannel(inputChannel)--JNI--&gt; nativeRegisterInputChannel(inputChannel)--C++--&gt; (NativeInputManager im)-&gt;registerInputChannel(env, inputChannel, ...)-&gt; InputManager::-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, ...)-&gt; InputDispatcher::registerInputChannel() &#123; Connection::ctor(inputChannel, ...), mLooper-&gt;addFd(inputChannel-&gt;getFd(), ...) &#125;Looper::addFd() &#123; epoll_ctl(ADD/MOD), 加入到 mRequests 队列 &#125;接收event------------------------ViewRootImpl#requestLayout() / invalidate() / setLayoutParams() 等-&gt; ViewRootImpl#scheduleTraversals()-&gt; ViewRootImpl#scheduleConsumeBatchedInput()--Looper机制--&gt; (ConsumeBatchedinputRunnable mConsumedBatchedInputRunnable)#run()-&gt; ViewRootImpl#doConsumeBatchedInput()-&gt; (WindowInputEventReceiver mInputEventReceiver).consumeBatchedInputEvents()-&gt; InputEventReceiver#consumeBatchedInputEvents()--JNI--&gt; nativeConsumeBatchedInputEvents(receiver)--C++--&gt; (NativeInputEventReceiver receiver)::consumeEvents() &#123; 无限循环: [ (InputConsumer mInputConsumer==WRAPS(inputChannel == InputEventReceiver 构造时传入)).consume(), (JNI调java) InputEventReceiver#dispatchInputEvent()] &#125;InputEventReceiver#dispatchInputEvent() --重载--&gt; WindowInputEventReceiver::onInputEvent(event) -&gt; ViewRootImpl#enqueueInputEvent()InputConsumer::consume()-&gt; mChannel-&gt;receiveMessage(), 是 socketpair() 客户端 &#123; UNIX Socket ::recv(mFd) &#125; InputReader处理12345678910111213141516InputReaderThread::processEventsLocked(deviceId, rawEvents, count)-&gt; --::processEventsForDeviceLocked(deviceId, rawEvent, batchSize) [或 add/remove)DeviceLocked / handleConfigurationChangedLocked]-&gt; mDevices中取 (InputDevice device)::process(rawEvents, count) &#123; for rawEvents: 命令扔掉 or &#123; for mMappers: InputMapper::process(rawEvent) &#125; &#125; mMappers 在 InputReader::createDeviceLocked() 中添加, 包括 (Switch/Vibrator/Keyboard/Cursor/MultiTouch/SingleTouch/Joystick)InputMapper-&gt; InputMapper子类::process(rawEvent), 以Keyboard为例 &#123; mReader-&gt;mQueuedListener::notifyKey(args) &#125;-&gt; QueuedInputListener::notifyKey(args) &#123; (Vector&lt;NotifyArgs*&gt; mArgsQueue).push(new NotifyKeyArgs(*args)) &#125;(QueuedInputListener mQueuedListener)::flush()-&gt; NotifyArgs::notify(mInnerListener==InputDispatcher)-&gt; InputDispatcher::notifyKey(NotifyKeyArgs) &#123; mPolicy-&gt;interceptKeyBeforeQueueing(), enqueueInboundEventLocked(newEntry) &#125;InputDispatcher::enqueueInboundEventLocked(entry) &#123; mInboundQueue.enqueueAtTail(entry) &#125;InputReaderThread和InputDispatcherThread两线程对 inBoundQueue 的访问是通过 InputDispatcher::mLock 锁来保护的. InputDispatcher处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263InputDispatcher::dispatchOnce() &#123; dispatchOnceInnerLocked() 最终目的 UNIX Socket send 给注册的 inputChannel, mLooper-&gt;pollOnce() 最终目的 epoll_wait(inputChannelFd) 确认应用返回的已处理消息 &#125;dispatchOnceInnerLocked() [或 runCommandsLockedInterruptible()]------------------------ &#123; mInboundQueue.dequeueAtHead() , 以键盘 TYPE_KEY 为例 dispatchKeyLocked() &#125;InputDispatcher::dispatchKeyLocked(currentTime, entry, dopReason, nextWakeupTime) &#123; (policy==NIM) intercept key 转为 CommandEntry, 或 扔掉, 或 findFocusedWindowTargetsLocked(), dispatchEventLocked(currentTime, entry, inputTargets) &#125;-&gt; dispatchEventLocked() &#123; foreach (InputDispatcher::Connection connection): prepareDispatchCycleLocked() &#125;-&gt; prepareDispatchCycleLocked()-&gt; enqueueDispatchEntriesLocked() &#123; enqueueDispatchEntryLocked(), 若之前为空则 startDispatchCycleLocked() &#125;-&gt; enqueueDispatchEntryLocked() &#123; connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry) &#125;(policy==NIM) intercept key-&gt; InputDispatcher::postCommandLocked()--重新以CommandEntry形式dispatch--&gt; InputDispatcher::runCommandsLockedInterruptible() &#123; (commandEntry-&gt;command函数指针==doInterceptKeyBeforeDispatchingLockedInterruptible)(commandEntry) &#125;-&gt; (mPolicy==NIM)-&gt;interceptKeyBeforeDispatching()--JNI回调java--&gt; InputManagerService#interceptKeyBeforeDispatching()--JAVA--&gt; (mWindowManagerCallbacks==InputMonitor).interceptKeyBeforeDispatching()-&gt; (WindowManagerService mService).(WindowManagerPolicy mPolicy==Binder通信的PhoneWindowManager).interceptKeyBeforeDispatching()--Binder通信--&gt; PhoneWindowManager#interceptKeyBeforeDispatching() &#123; HOME/MENU/SEARCH 等全局键处理 &#125;InputDispatcher::startDispatchCycleLocked(currentTime, connection) &#123; 以键盘 TYPE_KEY 为例 connection-&gt;( InputPublisher inputPublisher ==WRAPS(mChannel)== connection 建立时的 inputChannel == NativeInputChannel 建立时的 inputChannel )-&gt;publishKeyEvent(), 如果成功则 connection-&gt;outboundQueue.dequeue(dispatchEntry), connection-&gt;waitQueue.enqueueAtTail(dispatchEntry) &#125;-&gt; InputPublisher::publishKeyEvent()-&gt; (InputChannel mChannel)::sendMessage(InputMessage::ctor()) &#123; UNIX Socket ::send(mFd, msg ...) &#125;InputDispatcher::Connection 类在 InputDispatcher.h 中. 所有的connection在 InputDispatcher::registerInputChannel() 中注册.mLooper-&gt;pollOnce()-------------------------&gt; Looper::pollInner() &#123; epoll_wait(inputChannelFd), foreach event: [pushResponse(events, mRequests[idx])], foreach in mMessageEnvelopes: messageEnvelope.handler-&gt;handleMessage(messageEnvelope.messge), foreach in mResponses: response.request.callback-&gt;handleEvent() &#125;-&gt; Looper::pushResponse() &#123; 添加到 mResponses 队列 &#125;-&gt; response.request.callback-&gt;handleEvent()-&gt; InputDispatcher::handleReceiveCallback() &#123; connection-&gt;inputPublisher.receiveFinishedSignal(), (InputDispatcher d)-&gt;finishDispatchCycleLocked() &#125;InputPublisher::receiveFinishedSignal()-&gt; mChannel-&gt;receiveMessage(), 是 socketpair() 服务器端InputDispatcher::finishDispatchCycleLocked()-&gt; InputDispatcher::onDispatchCycleFinishedLocked() &#123; 通知并准备下个 dispatch cycle &#125;--mCommandQueue队列--&gt; InputDispatcher::doDispatchCycleFinishedLockedInterruptible() &#123; connection-&gt;waitQueue.dequeue(dispatchEntry), startDispatchCycleLocked() &#125;Looper机制----------------------------------ActivityThread#main()-&gt; Looper#loop() &#123; 无限循环: 处理 (MessageQueue queue).next() &#125;-&gt; MessageQueue#next()--JNI--&gt; nativePollOnce()--C++--&gt; NativeMessageQueue::pollOnce()-&gt; Looper::pollOnce()","tags":[],"categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"用Octopress在GitHub上搭建博客","date":"2013-09-01T05:23:00.000Z","path":"博客搭建/octopress-setup/","text":"目录 {:toc} 备料注册 GitHub 账户并创建一个空仓库 (假定注册名为 yourname, 注册邮箱 yourname@gmail.com, 下同) 创建空仓库 yourname.github.io 下载并配置 Git下载 Linux 使用系统包管理安装git Windows MsysGit vim着色：MsysGit上的vim着色文件不全, 可从完整vim73的syntax目录拷过来, 如 /usr/share/vim/vim73/syntax 配置设置 LANG 环境变量(可以不设LC_ALL; 可以不是zh_CN, 后缀是UTF-8即可;) 12345678910111213141516171819# locale和中文显示touch ~/.bashrcecho 'export LANG=\"en_US.UTF-8\"' &gt;&gt; ~/.bashrctouch ~/.inputrcecho 'set meta-flag on' &gt;&gt; ~/.inputrcecho 'set convert-meta off' &gt;&gt; ~/.inputrcecho 'set input-meta on' &gt;&gt; ~/.inputrcecho 'set output-meta on' &gt;&gt; ~/.inputrctouch ~/.vimrcecho 'set fileencodings=utf-8' &gt;&gt; ~/.vimrc# git optionsgit config --global user.name \"yourname\"git config --global user.email \"yourname@gmail.com\"git config core.autocrlf falsegit config credential.helper 'cache --timeout=3600' # Keep your password cached in memorygit config github.user \"yourname\"# ssh keyssh-keygen -t rsa -C \"yourname@gmail.com\"cat ~/.ssh/id_rsa.pub # 将内容复制到 https://github.com/settings/ssh 上 下载并配置 Ruby(1.9.3)下载 Windows 7zip包解压(假设到 D:\\ruby1.9.3), 添加到系统PATH 下载并配置 DevKit(wiki) 1.9.3 配对 DevKit-tdm, 解压(假设到 D:\\ruby1.9.3-DevKit), 添加到系统PATH 1234567cd /D/ruby1.9.3-DevKitruby dk.rb initruby dk.rb review # 确认ruby位置正确ruby dk.rb install# 验证DevKitgem install json --platform=ruby # 能看到 build nativeruby -rubygems -e \"require 'json'; puts JSON.load('[42]').inspect\" # 确认json gem安装成功 Linux 使用 RVM(Ruby版本管理) 1234567# install RVM stable with ruby in user's $HOME\\curl -L http://get.rvm.io | bash -s stable --ruby # 反斜杠是防止使用到 ~/.curlrc 定义的 alias# rvm安装完毕# rvm list knownrvm install 1.9.3rvm use 1.9.3 --default# ruby -v 配置1234# gem更新源gem sources --remove http://rubygems.org/ # 要包含最后的斜杠gem sources -a http://ruby.taobao.org/gem sources -l # 验证源只有 ruby.taobao.org 安装Octopress12345git clone git://github.com/imathis/octopress.git mygithubiocd mygithubiogem install bundler # 不是 bundlebundle install # 下载安装依赖项目(bundle是ruby的依赖管理工具)rake install # 编译octopress项目(Rake to Ruby == Make to C) 1rake setup_github_pages hellip; 不是内部命令错误 1 Rakefile文件 My Octopress Page is coming soon &amp;hellip; 在 &amp;hellip; 前加 ^ (Windows cmd转义) setup_github_pages目标主要做了2件事: 将原来git upstream的 origin 改到 octopress 将你在 GitHub 上的博客地址(如 yourname.github.io) 作为 origin. 验证: git remote -v 1234# rake new_post['hello octopress'] # 创建新markdown博文rake generate # 确保 `.gitignore` 包含忽略 _deploy 目录# rake preview # 可通过本机4000端口预览# rake deploy # push 到 GitHub 博客项目的 master 分支 错误排查找不到python21312cd D:\\Python27mklink /H python2.exe python.exe 基本使用和配置使用rake new_post[&#39;new-post-today&#39;] 生成新博文rake new_page[&#39;new-page-in-here&#39;] 生成新页面(不属于博文系列)配置2_config.yml123456# 博客链接格式permalink: /blog/:year/:month-:day-:title.html# 使用kramdownmarkdown: kramdown# SEOdescription: yourname的技术博客 自动生成目录6使用kramdown(下面配置), 写博客时加入以下两行即可自动生成目录:12* list element with functor item&#123;:toc&#125; 目录样式touch sass/custom/_styles.scss, 添加 12345678910111213141516#markdown-toc:before &#123; content: \"TOC\"; font-weight: bold;&#125;ul#markdown-toc &#123; list-style: none; display: inline-block;// float: left; background-color: LightGray; margin-right:2em; border-radius: 1em; box-shadow: 0px 1px 4px; -moz-box-sizing: border-box; padding: 10px 10px 10px 20px;&#125; 侧栏about me_config.yml 的 default_asides 里添加 custom/asides/about.htmltouch source/_includes/custom/asides/about.html, 添加内容1234567&lt;section&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;p&gt;一句话介绍&lt;/p&gt; &lt;p&gt;微博: &lt;a href=\"http://weibo.com/yourname\"&gt;@yourweiboname&lt;/a&gt;&lt;br/&gt; &lt;p&gt;豆瓣: &lt;a href=\"http://douban.com/yourname\"&gt;@yourdoubanname&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;&lt;/section&gt; 分类标签(支持中文)/categories5categories 多个以逗号分隔 中文支持: 确认 plugins/category_generator.rb 中 write_category_indexes 和 category_link 函数包含 to_url 调用 (url 不区分大小写, 不用再调 downcase)12345# 109行附近self.write_category_index(File.join(dir, category.to_url), category)# 176行附近\"&lt;a class='category' href='/#&#123;dir&#125;/#&#123;category.to_url&#125;/'&gt;#&#123;category&#125;&lt;/a&gt;\" touch plugins/category_list_tag.rb, 添加内容123456789101112131415module Jekyll class CategoryListTag &lt; Liquid::Tag def render(context) html = \"\" categories = context.registers[:site].categories.keys categories.sort.each do |category| posts_in_category = context.registers[:site].categories[category].size html &lt;&lt; \"&lt;li class='category'&gt;&lt;a href='/blog/categories/#&#123;category.to_url&#125;/'&gt;#&#123;category&#125; (#&#123;posts_in_category&#125;)&lt;/a&gt;&lt;/li&gt;\\n\" end html end endendLiquid::Template.register_tag('category_list', Jekyll::CategoryListTag) touch source/_includes/asides/category_list.html, 添加内容123456&lt;section&gt; &lt;h1&gt;Categories&lt;/h1&gt; &lt;ul id=\"categories\"&gt; &#123;% category_list %&#125; &lt;/ul&gt;&lt;/section&gt; _config.yml 中 default_asides 添加 asides/category_list.htmlJekyll+lunr.js 即时搜索7 下载 jekyll_lunr_js_search.rb 放到 plugins 目录. 可按 8 中提示修改一个小bug. 下载 jquery.lunr.search.js 放到 source/javascripts 目录 jQuery 已在 Octopress 中内置: source/javascripts/libs/jquery.min.js 下载 以下几个 javascript 依赖, 放到 source/javascripts 目录 lunr.min.js mustache.js date.format.js URI.min.js gem install nokogiri json 安装依赖, gem list 查看 nokogiri 版本(假设为 1.6.0) 修改 Gemfile, 标明依赖 gem &#39;nokogiri&#39;, &#39;~&gt; 1.6.0&#39; rake new_page[&#39;search&#39;], 编辑 search页(source/search/index.markdown): 屏蔽页面被索引有两种方式 每个 markdown页 的 YAML配置头 加 exclude_from_search: true _config.yml 统一添加(即使没有也添加, 防止索引运行出错) 12lunr_search: excludes: [rss.xml, atom.xml] 首页添加链接到 search页面 重新 rake generate Header about页面 1rake new_page['about'] # 生成 source/about/index.markdown 头部导航菜单 /source/_includes/custom/navigation.html 加入 about页面 链接. 字体 source/_includes/custom/head.html 全部注释掉, 不装载 Google Webfonts(此字体没有包含中文, 粗体中文显示不出) sass/custom/_fonts.scss 添加(最佳 Web 中文默认字体) 123$heading-font-family: arial, sans-serif;$header-title-font-family: arial, sans-serif;$header-subtitle-font-family: arial, sans-serif; 社交功能分享功能JiaThis3_config.yml 加入变量 12# JiaThisjiathis: true source/_includes/post/sharing.html 尾部 &lt;/div&gt; 之前添加 123&#123;% if site.jiathis %&#125; &#123;% include post/jiathis.html %&#125;&#123;% endif %&#125; touch source/_includes/post/jiathis.html, 将从 JiaThis 获得的代码放入其中 评论功能多说4_config.yml 加入变量 123# DuoShuo commentsduoshuo_comments: trueduoshuo_short_name: yourname source/_layouts/post.html 中 disqus 代码下添加 (单独页面也加评论的话 source/_layouts/page.html 中也放相同代码) 123456&#123;% if site.duoshuo_short_name and site.duoshuo_comments == true and page.comments == true %&#125; &lt;section&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;div id=\"Comments\" aria-live=\"polite\"&gt;&#123;% include post/duoshuo-thread.html %&#125;&lt;/div&gt; &lt;/section&gt;&#123;% endif %&#125; 创建 source/_includes/post/duoshuo-thread.html, 将从多说获得的代码放入其中 统计功能站长统计source/_includes/custom/footer.html 中加入注册后给出的统计代码. 换主题bootstrap-theme , 或者其他的 123git clone http://github.com/bkutil/bootstrap-theme.git .themes/bootstrap-themerake install['bootstrap-theme'] # 注意: 换主题后所有非custom目录下的内容都会被覆盖掉！！rake generate i18nI forked from hendricius/jekyll-i18n and adapted to octopress(in octopress-i18n). However, AFAIK there’s no i18n capable themes right now. You have to create your own theme branch and adapt to i18n. html中写 1&#123;% i18nvar %&#125; , source/_locales/zh_CN.yml 中定义对应变量 i18nvar: 中文名称 更新1234git pull octopress master # 自动或手动mergebundle installrake update_sourcerake update_style 使用 travis-ci 自动编译发布 登录Travis-CI, 注册授权, 右上角 Accounts, 对应项目repo 置为 ON 生成 https 访问 github 所需的 token. 可用9中的界面方法, 或10中的curl直接获取 gem install travis; travis encrypt GH_TOKEN=&lt;token&gt; 生成加密的token 修改 .travis.yml, 几点注意: 调用 rake 命令时前面要加 bundle exec, 防止 rake 命令版本冲突 Travis 默认使用 Gemfile.lock 中的信息, 但此文件中包含平台相关的build信息, 会导致nokogiri编译问题11. 所以最好是将 Gemfile 拷贝出一份独立的 Gemfile.travis 供 Travis 使用. Gemfile.travis 中的 source 此时也可改用通用的 rubygems Travis上构建时如果出现 Liquid Exception: Gist replied with 301 错误提示, 是Octopress的一个bug, 则需要更新一下Octopress12 123456789101112131415161718192021branches: only: - sourcelanguage: rubyrvm: - 1.9.3gemfile: - Gemfile.travisbefore_script: - git config --global user.name \"yourname\" - git config --global user.email \"yourname@gmail.com\" - export REPO_URL=\"https://$GH_TOKEN@github.com/$GH_REPO.git\" - bundle exec rake setup_github_pages[$REPO_URL]script: - bundle exec rake generateafter_script: - bundle exec rake deployenv: global: - GH_REPO=\"your_github_name/your_github_name.github.io\" - secure: \"&lt;your-travis-encrypted-token&gt;\" 修改 Rakefile 隐藏token 12345- puts \"Added remote #&#123;repo_url&#125; as origin\"+ puts \"Added remote as origin\" # don't put repo_url in travis-ci as it may contains token- system \"git push origin #&#123;deploy_branch&#125; --force\"+ system \"git push origin #&#123;deploy_branch&#125; --force --quiet\" # hide github token 支持https提交 12345- puts \"(For example, 'git@github.com:yourname/yourname.github.com)\"+ puts \"(For example, 'git@github.com:yourname/yourname.github.com' or 'https://github.com/yourname/yourname.github.com')\"- user = repo_url.match(/:([^\\/]+)/)[1]+ user = repo_url.match(/[\\/:]([^\\/]+)\\/[^\\/]+$/)[1] 跳过不需要触发travis的commit 12345- message = \"Site updated at #&#123;Time.now.utc&#125;\"+ message = \"Site updated at #&#123;Time.now.utc&#125;\\n\\n[ci skip]\"- system \"git commit -m \\\"Octopress init\\\"\"+ system \"git commit -m \\\"Octopress init\\n\\n[ci skip]\\\"\" README.markdown 加入 build 状态图标 1[![Build Status](https://travis-ci.org/yourname/yourname.github.io.png?branch=source)](https://travis-ci.org/yourname/yourname.github.io) 1.Octopress 笔记 ↩2.我的Octopress配置 ↩3.在 Windows7 下从头开始安装部署 Octopress ↩4.为 Octopress 添加多说评论系统 ↩5.讓Octopress有中文分類及側邊列 ↩6.Table of Contents in Octopress ↩7.Jekyll+lunr.js ↩8.使用Jekyll-Bootstrap搭建博客时出现的问题 ↩9.打造Octopress博客在线写作平台 ↩10.Octopress+Prose+Github+Travis CI = Coders’ Blog ↩11.travis-ci-nokogiri-LoadError ↩12.octopress-gist-replied-with-301 ↩13.Probmes using syntax highlighting with pygments on windows ↩","tags":[],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/categories/博客搭建/"}]}]}